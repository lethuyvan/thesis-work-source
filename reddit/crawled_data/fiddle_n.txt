> What I am used to is importing what I need, creating a class of variables, and then inserting functions within that class.

So why not do that then? I don't think that OO style is the best way to write your code; I think it's simple enough that you can write it in a procedural style, by passing data in and out of functions. But Python does have classes, so if you are comfortable writing in them, I would recommend for you to do that.
pytest over unittest is the big one for me. Writing unit tests is just so much nicer now.
Last time I checked it wasn't compatible with 32-bit Windows 10. That's what my device came preinstalled with and I CBA to reinstall the 64-bit version XD
Representative of most people who own a Mac. Yes, there are a few companies that develop on macOS. Those companies will care that it's UNIX-based. But the vast majority of Mac owners are regular consumers who fit into the category I described above.
Let's not encourage `for...else` please! Many developers don't see `for...else` and `while...else` in the wild and either don't understand it properly or don't know how to use it.

Much better solution is to use a function with an early return:

    def fn():
        for something in sequence:
            if etc:
                return
        print('else block code goes here')
If you even have to ask that question, then you know nothing. No, I didn't do extensive peer-reviewed research to come to that conclusion. But you don't have to. Just ask any group of representative people (i.e. not a group of developers, for example) if they've even *heard* of Linux or Unix.
Because Android app support is not enough. You need to have the Play Store and Google Play Services preinstalled on the device.
Most people who own Macs don't know/care that it's built in UNIX. Same with Android users and Linux. As long as they can browse the web and use their favourite apps, they don't care what's under the hood.
Lol, any third ecosystem would be dead in the water due to lack of apps. After seeing what happened to Windows Phone, Ubuntu OS, Firefox OS, Sailfish and others, it would be madness for OEMs to try to do that again.
Nah, eventually Google can just say new devices, new apps or new app updates need to be targeted to Fuschia and that's that.
> When Leonard and Penny hooked up, though, and the Indian guy somehow cured his social awkwardness, it lost its way for me.

I assume you mean when Leonard and Penny get into a relationship for the long haul? Leonard and Penny first start dating all the way back around Series 1 - 2, whereas it's something like Series 6 when Raj cures his inability to talk to girls.
What about recursion do you find confusing? It's just a function that calls itself.
Recursion seems to be way more popular in theory than in real life. Try to understand it if you can, but don't feel pressured to because very few real-world problems require it. Certainly, I've never seen recursion used out in the wild.
* It's one of the countries where iPhone usage is highest, so iMessage is a viable option.
* Everyone has unlimited texting, not the case in many countries.
Yeah, I just assumed that, having never run a Python file outside of Jupyter, you didn't know that the main way of running a Python script was through the terminal. Which is why I told you about that rather than some other way.
Open a terminal prompt, change directory to the directory containing the file, and then type `python file.py`, switching file.py with the actual filename.
You could use a shebang to indicate your code is 3.7 only. Or raise an exception if the Python version is less.

Of course, if you run such code in an older Python 3 version, the code will not work. But this is true if you use any new construct in any particular version of Python. If you try to run code with f-strings in Python 3.5, it won't work. If you try to use the with statement in Python 2.0, that won't work either. Virtually no software is forwards-compatible in this way.
https://www.reddit.com/r/python/comments/8cojrq
I would definitely start a personal project if I were you. Books are great for the theory, but you need to actually start writing code on your own as well. If you want to learn to cook, you won't get there just by reading recipe books. Programming is exactly the same.
Probably a good idea to say which language...
`*args` and `**kwargs` are really important in certain places where you have a variable number of arguments, or you don't know what the arguments will be.

A good example is `print`. When you use `print()`, you can pass multiple arguments to it. You can say `print(foo, bar, baz, ...)` and so on. You can go on for as many arguments as you like. How does that work in the print definition? Clearly, print cannot be giving each parameter a name, that would be crazy and wouldn't work for an infinite number of parameters. The answer is \*args. 

Another example is creating decorators. Decorators take in a function and return a different function, binding it to the name of the original function. Below is an example of a decorator that prints the name of any function that it decorates:

    def print_name(fn):
        def print_fn_name(*args, **kwargs):
            print(fn.__name__)
            return fn(*args, **kwargs)
        return print_fn_name

    @print_name
    def add(x, y):
        return x + y

    >>> print(add(1, 2))
    add
    3

The `@print_name` decorator has no idea about the function it will be taking in, and so has no idea of the arguments that function will have. But it still needs to be able to call the original function as part of its functionality. How does it do that? `*args` and `**kwargs`.

EDIT: lol, looks like lots of people have done the decorator example XD Still, I think the print example is a better example :)
It's important to know *why* there's a preferred indentation method in the first place.

In Python, whitespace matters. This is unlike so many other languages, where you use a curly brace to denote a new code block. Both tabs and spaces can be used for indentation, but you can't mix both! Doing this causes your code to screw up in Python 2, and Python 3 will throw an exception if it detects you've done this. 

Now, imagine sharing code. You might want to share your Python code with others online. You might want to edit Python code others have shared. Because of the PEP 8 directive, you can be fairly confident that the code will use spaces, so generally you don't have to worry about indentation style they are using. If the community was split 50:50 between tabs and spaces, this would be more of a headache.

Imagine working on code professionally in a team. Everyone reads and shares other people's code. If people used their preferred indentation style, it would be madness. A standard indentation style must be agreed on within teams to prevent whitespace issues within Python code.
Definitely a great article, well done! I think it will be very useful for beginners to see the multiple ways in which they can use classes to create reusable software.

As a beginner, the hardest problem that I had was knowing when to use functions vs when to use classes. It's something that not many tutorials touch on - teaching the cues one should recognise that tells them that they should shift from one to the other. An example of trying to do this in a functional style, discussing the code smells (constantly passing in and returning the same parameters, many functions not grouped together) and then showing the OO style code.
You can pull data from xml using the standard library xml package, or the third-party lxml package. I would recommend using lxml.

You can write data to Excel using either standard libary xlrd or third-party openpyxl. Again, I recommend openpyxl.

Reading/writing to text files is as simple as opening the file and manipulating the contents. PDFs are a little harder but it's possible to play around with those too.
I'm not sure tbh. I had such an issue a while back - I just reverted to using print statements everywhere XD I'm sure there's a cleverer solution though.
Printing every variable is very basic debugging. It's a good start, especially for beginners, but eventually you'll want to use a proper debugger. You have two choices IMO: learn and use either the pdb module, or use the debugger within one of the popular IDEs (e.g. PyCharm). Since you like the Atom text editor, pdb might be the better choice for you, though usually I would recommend people to use the PyCharm debugger.  With pdb, you can put a breakpoint in your code right where you want by typing `import pdb; pdb.set_trace`. Then, when you run your code, it will stop right at the breakpoint. You can then type out the names of variables into the REPL to inspect them.
Perhaps if you can't get turtle to work, you should figure out why instead of ditching it immediately :)

I use VS Code but only because I have a potato computer. Otherwise I would use PyCharm.
Just because you *can* go crazy with f-strings, doesn't mean you *have* to go crazy with them. Just use them sensibly. I love f-strings, the syntax is much less verbose than `str.format()`.

EDIT

Also, I'm sure your first example is needlessly complex; why wouldn't the below work?

    print(f'"":=^{COLUMNS}')
    print(f'" Comparing Playlists ":=^{COLUMNS}')
Nokia 8 is around the same cost as the old Nexus devices and was pretty much the first device after the Pixels to get 8.1 upgrade. Nokia 3 is a lot cheaper, so you have to expect those devices to get it later.
This is literally one of the easiest programming questions ever. Go actually do some research in Google and try to actually come up with a solution. Stop being so lazy.
Getters and setters are a must in languages that *don't* have properties. If you don't create getters and setters in those languages, you are incompetent.
Choose Python 3.
I was thinking more like Bash, but I guess Powershell too
FYI, I feel like renaming files is something that is better served by a shell script rather than a Python script.
Python is free. Google it and you can download it. MATLAB is very focused towards engineering, whereas Python is a general purpose programming language that you can use to write all kinds of programs and software. I am currently running Python on an Intel Atom with eMMC storage and 2GB RAM - your core i5 will have no problems :)
Firstly, that wasn't the enthusiasts, it was places where Windows Phone was being properly marketed and sold by carriers.

Secondly, exceeding iPhone market share in a small number of small, poorer countries is nothing to shout about. When it's a number of low end phones vs one high end phone, and you are settling them in these types of countries, the former should absolutely crush the latter in market share.
You just have to keep at it, really. Yeah, I know that doesn't help that much, but if you keep alternating between theory and practice, it will eventually click.
> The CEO of stack overflow wrote an article about how colleges are teaching Java and he laments how hard C++ was to learn.

[He actually said C, not C++ :\)](https://www.joelonsoftware.com/2005/01/02/advice-for-computer-science-college-students/) 
There's a design philosophy called TDD - test driven development. And TDD is all about writing tests first and then restricting yourself to writing only the production code needed to pass the test. Robert Martin (aka Uncle Bob), who is one of the famous names of the software engineering world, has written up what he calls the [3 laws of TDD](http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd), which are as follows:

1. You are not allowed to write any production code unless it is to make a failing unit test pass.
1. You are not allowed to write any more of a unit test than is sufficient to fail; and compilation failures are failures.
1. You are not allowed to write any more production code than is sufficient to pass the one failing unit test.

Writing any more code without writing a test first would violate rule 1. But writing any more tests in order to create new code, without first fixing the broken tests, would violate rule 2. It follows on from these rules that you must first fix the tests that are broken before going on to write new features.

I would definitely go and fix all tests before writing new code. That should be your first priority - proving to yourself that your current code actually works before writing new code.
So, you should always organise your code into functions as the default, in my opinion. But it's very easy to find yourself passing and returning the same parameters over and over again through a number of functions. Here's such a contrived example with code for a board game:

    def play_turn(gameboard, player_list):
        move_forward(gameboard, player_list)


    def move_forward(gameboard, player_list)
        change_position(gameboard, player_list)


    def change_position(gameboard, player_list):
        ...


In such a situation it's better to make a class instead to group these related functions, like so:

    class Game:

        def __init__(self, gameboard, player_list):
            self.gameboard = gameboard
            self.player_list = player_list 

        def play_turn(self):
            self.move_forward()

        def move_forward(self):
            self.change_position()

        def change_position(self):
            ...


In the above class, there's no need to pass the same parameters into and out of the functions, because they have been initialised as instance attributes and passed in to the functions through `self`.
If you ran the code, you'd see the error "missing parentheses in call to print". Sometimes the editor shows an error but it's not immediately evident why that's the case - running the code can often help.
On the line above `print(m)`, consider printing out `x` and `y` too. This should help clear it up for you.
My opinion is that complex numbers is an intermediate level concept. Certainly, I have never used them and unless you are using Python for science, maths or engineering it's something that you don't really need to care about. 

I think a beginner level tutorial should be very focused on the basics. For example, how to actually define an int or a float. I don't actually see any code in the "Plain integers" or "floating point numbers" section that shows you how to actually define one of these types, whereas the next section dives straight into a detailed dive of complex numbers.
Usually you run a Python file from command line, not double clicking. And I think the command is python3 file.py if you have both versions installed. Getting Py3.6 to override Py2.7 by default is a little tricky to describe as it's a OS-level configuration and depends on which one you use.
So, I can confirm that your code works properly in Py3.6 and has the `NameError` in Py2. The issue is due to how `input()` works differently in the two versions. 

In Python 3, `input()` takes in user input and returns a string, so if you type in `a`, the script interprets this as the string `'a'` and everybody's happy.

In Python 2, `input()` takes in user input and runs `eval()` on it. If you type in `a`, the script interprets this as the **variable** `a` instead, not the string. Of course, variable `a` doesn't exist and this is the cause of your `NameError`.
Until you show us your code, we can't really tell you what the issue is.
Yeah, you are now limited by physical specs rather than the language.
There's no hard and fast rule around it. My rough guideline is that, if you have to go above 10 parameters, it's a code smell that your code is too complex and could be refactored.
Actually I believe that with Py3.7, you can have no limit at all on how many you want.
I think you need to look up on defining classes again. Issues with the code:

* You are trying to call `difficultySettings()` as if it's a regular function rather than an instance method. You need to do `player.difficultySettings()`
* When you define `difficultySettings()` in your class, the first argument should be `self`. Also, `self.change` is not a valid parameter to an instance method.
* `__init__()` should be the first method of your class, by convention.
* Please follow PEP8 naming conventions. Class names should be in UpperCamelCase, and function/method names should be snake_case.
This is such a broad question that it's much better to either Google this question or look at the resources on the sidebar. Do you have any specific things you would like tips on?
Having just looked at your numerics tutorial, I think that you have a mixture of beginner and intermediate stuff in there. I think that you need to decide which audience you want to target your article to and then focus it more on that audience.
Your solution looks fine so long as the dictionary is one level down and there is only one dictionary as the solution. I propose one small enhancement though: 

    for v in dictionary.values():
        if v['name'] == 'c':
           return v

You don't need to iterate over `items()` as you are only using the values of the dictionary, not the keys.
List comprehensions are great, but only for 2-3 statements only. If you have to go over that then it's probably better to use a regular loop. 
So, I used to think like you. I used Snipping Tool for literally over ten years and could never understand why I'd want another tool. Then, my coworker persuaded me to install Greenshot on my work machine. And I couldn't believe just how much better it was. I installed ShareX later on my personal computer and I haven't looked back. The features of Greenshot and ShareX are seriously killer.
Dedicated apps are still better for this though. ShareX is amazing.
Snipping Tool does that by default. Though, tbh if you aren't using Greenshot or ShareX, you are doing it wrong anyway.
Vista definitely did not have it.
No, MS Word won't autocorrect "HELLO", it will autocorrect "hELLO".
So, the pseudocode for tasks like this where you transform data from one file format to another is pretty much the same whatever you do:

1. Read the file into a Python data structure
1. Manipulate the data using Python functions/commands.
1. Write the data out to a new file.

You probably could use pandas.read_csv() to read the file in, though you would need to specify that the file is space delimited rather than comma delimited.

If it was me, I wouldn't have done that, simply cos I don't know Pandas all that well, but also because I think a pure Python solution is pretty easy to code. This is what I would do:

1. Create an empty list.
1. Iterate over the input file, reading each line of the file and splitting the string to create a list. Append this list to the list in step 1. You should now have a list of lists.
1. Iterate over the list of lists, using the list indices to help you decide which Protein you are dealing with.
The design of my code increased leaps and bounds when I followed TDD (test-driven development). Writing unit tests first, as well as only writing code to pass those unit tests, forced me to write code that was well-structured and decoupled, and also forced me to write the minimum amount of code required to do the job required. Once you start doing TDD, you'll find it a lot easier to write good code.
Let's say you had a bunch of related classes. And you wanted to add a method to each of those classes. The method would have the same name but their implementation in each class would be different, depending on the class in question. 

You could achieve a similar thing with single dispatch functions. The question is, why would you want to? I think one potential answer is if the method doesn't really fit with the classes that you want to add it to, and if it might be better class design to have the function in the global namespace instead. Single dispatch lets you have the function in global namespace, but still gives you that ability to have it do different things based upon different object type.
Something to add - it's important not to use this `@singledispatch` or `@x.register(y)` directly on instance methods. Consider the below:

    class Foo

        @singledispatch
        def bar(self, value):
            ...

        @bar.register(Foo)
        def _(self, value):
            ...

 The above will fail for two reasons

* Here, we are trying to register the class containing the overloaded functions. This will fail because we haven't finished defining the class yet. 

* More fundamentally - single dispatch looks at the type of the first argument. When you call `self.bar(value)`, it's easy to think that it'll be looking that the type of `value`. But you must remember that this is syntactic sugar for `Foo.bar(self, value)`. So, single dispatch will be looking at the type of `self`, not of `value`. 

These are fixed by bringing the dispatch functions into global namespace and having the methods call those functions instead.
I don't see where the `except` block is in your code.
When I said "there is no GOTO in Python", I was referring to plain Python. Obviously a third-party can add GOTO if they want to, as evidenced in your link.
There is no GOTO in Python, the design of Python and many other languages is to specifically avoid needing to have a GOTO.

What you want can be achieved using a `while True` loop. I've shown this below, whilst editing your code slightly to remove `then` (this isn't a Python construct) and to remove extraneous brackets:

    while True:
        action = input("Hit 'A' to accelerate, 'B' to brake, 'S' to slow down.")
        if action == "A":
            print("You are now moving at the speed of", (speed + 5), "kmph")
        if action == "S":
            print("You have fully decelerated to 0kmph")
        if action == "B":
            if speed == 0:
                print("You are stationary at 0kmph")
        else: 
            print("You have slowed down to", (speed - 5), "kmph")

The code in the `while True` block will run forever. If you want to end the loop, you either put a condition in the `while` loop, like so:

    while x > 0:
        ...

or use the `break` keyword to break out of the loop:

    while True:
        ...
        if x < 0:
            break
So, you should debug and find out why. If you aren't aware of how to debug, I recommend putting print statements around your code in key locations to print out what the contents of some of your variables are. This will help you figure out what the issue is.
Here's the thing - to answer that question I would have to explain what the genuine rationale for using a `while-else`loop is, and then explain what the alternative is. 

The problem is that in your case, you aren't even using the `while-else` loop in the one scenario where it could make sense. In your example, you could achieve the same thing by removing the `else` and having the `else` code dedented one level, like so:

    while s_avg_grade <=0 and s_avg_grade >=100 and counter != 11:
        s_name=input('Please enter the students name ')

        s_avg_grade=int(input('Please enter the students average grade '))

        counter += 1 #Add one to the counter each time the function is completed.

        grades.write(s_name + ' \n')
        grades.write(str(s_avg_grade) + ' \n')
        grades.close()
    print("Please enter a number between 0 and 100.")
    main()     




The problem is that, in your `while` statement, all three conditions have to be `True` to enter your loop. If even one of them is `False`, execution will go to the else clause.

Your while clause is thus:

     while s_avg_grade <=0 and s_avg_grade >=100 and counter != 11:

This can literally never evaluate to True because the first two conditions are contradictory. Hence, you go straight to `else`.

Btw, I would highly recommend NEVER using `while-else` constructs. A survey was done at a PyCon and it turns out most people could not fully understand how to understand `while-else` constructs. If many Python experts cannot understand it, I would recommend staying away.
To clarify what was said above:

For the first suggestion, they mean that:

* The `main()` function, where you call all of your other functions, should be at the bottom of the script.
* You should consider calling `main()` like so:


        if __name__ == '__main__':
            main()

* This will allow your script to be runnable but also be imported by other scripts.

---
Parameters are values that are passed into a function.

All `return` does is that it leaves a function. Much of the time, we want to return a value from a function. Returning a value means leaving the function with a value that we save to a variable outside the function.

I think, with parameters and `return`, a code example tells a thousand words, so I hope the below helps:

    def add(x, y):
        z = x + y
        return z

    a = add(1, 2)
    print(a)        # prints 3

Above, `x` and `y` are parameters to the `add()` function, and `z` is the return value.
Yup, precisely. Please see [this comment of mine](https://www.reddit.com/r/learnpython/comments/87bz2x/help_revise_my_random_number_gen_game/dwbr2hb/) for further information on unit testing.
No worries :)

This is a simple problem to solve, and for the future I would recommend the following things:

* Learn how to debug your code so that you can inspect your variables. Simple debugging would involve simply printing out the variables `number` and `nth_working_number` after every loop. This would have pointed to the issue fairly quickly. Once you get comfortable with using `print` statements, you can then learn how to use real debuggers such as the `pdb` module or the debugger included within IDEs.

* Learn how to write unit tests for your code. This time around, you found the bug by yourself by manually running the code. But as you write more complex code with multiple functions, it will be harder to root out bugs using manual testing. Writing unit tests for your code will help a long way with this.
When you paste code in Reddit, please indent by 4 characters so that all code is formatted correctly.

---

        if number_of_factors == x and nth_working_number == n:
            return number
        elif number_of_factors == x and nth_working_number != n:
            nth_working_number += 1
        else:
            number += 1

I think the problem here is that you don't increase `number` by 1 if you go into the elif statement, so you are always "stuck" on the same number. Try:

        if number_of_factors == x and nth_working_number == n:
            return number
        elif number_of_factors == x and nth_working_number != n:
            nth_working_number += 1
        number += 1


Have you written any unit tests for this code? Once you have followed other people's directions to put everything into either a function or a class (i.e. no global variables) then I highly recommend adding unit tests to this code, if you haven't done so already.
There's a link to projects in the FAQ in the sidebar. I think this thread didn't get any replies for two reasons: a) this particular question has been asked to death, and b) it's tricky to know what to recommend because it really depends on what interests you, and that's not something people can easily answer.
I don't quite understand the issue here - are you confused by what True and False mean...?
So, your code is very messy and it's very difficult to understand what's going on. I'm going to hazard a guess at what you would like to do. However, I highly highly recommend that you refactor this code and add unit tests around it.

---

The below code uses a `while True` loop. A `while True` loop will run forever until you `break` out of it. This loop will continue subtracting stamina from damage so long as damage is greater than 0. Once damage is 0 or less, we break out of the loop.

    def attack(self):
        while True:
            self.dmg -= self.stamina
            if self.dmg > 0:
                print ('You use up some of your stamina, you have {} energy left'.format(self.dmg))
            else:
                print('You have run out of stamina')
                break
Given that you are asking about `l` and `t`, I think that before anything else, you need to understand how iteration works. There are plenty of web articles on for-loops and iteration and I advise you to Google and read up on them. I'll try to give a quick overview below though:

---

We use a for-loop when we want to iterate over a data structure of some kind. For example, say you have a list:

    letters = ['a', 'b', 'c', 'd', 'e']

Let's say that I want to access each element of this list in turn and then print it out. One obvious way would something like the below:

    >>> print(letters[0])
    a 
    >>> print(letters[1])
    b 
    >>> print(letters[2])
    c 
    >>> print(letters[3])
    d
    >>> print(letters[4]) 
    e

This works, but the solution has a number of flaws. You have to repeatedly access list `letters` multiple times. You have to remember the size list so that you can access every element. You can easily miss one element. And so on...

The way we fix this is by iterating over the list with a for loop:

    >>> for x in letters:
    ...     print(x)
    ...        
    a
    b
    c
    d
    e

The for-loop accesses every list element in turn, and assigns that element to variable `x`. In the indented code block below the for-statement, we can then access `x` and use it however we want (here, we've just decided to print out whatever `x` is).

Whatever variable name we choose for the iterator variable is not technically important. For example, instead of `x` I can use `letter` like so:

    >>> for letter in letters:
    ...     print(letter)
    ...        
    a
    b
    c
    d
    e


Many data structures are iterable. If you iterate over a list or tuple, you get the elements of each list/tuple (as seen above). If you iterate over a string, you get each character back:

    >>> word = 'hello'
    >>> for letter in word:
    ...     print(letter)
    ...        
    h
    e
    l
    l
    o

If you iterate over a dictionary, you get dictionary keys back. Other data structures work in different ways.

---

Try get your head around iteration, and then once you understand it properly, try and have a look at the StackOverflow solution again and see if you have any more questions.
Is there any part of it in particular that you don't understand, or is it everything that you don't understand?
I develop pretty much exclusively in Python, so my answer to your first question is yes.
For Windows Phone 8, "live tiles" genuinely could only update every 30 mins. If you were an OEM, you could get round this, but everybody else could not. It's why every app that tried to create a clock tile in Windows Phone 8 did not work, and the only one that did work was HTC's clock. 

I think for Windows Phone 8.1 they reduced it to 1 min. Not sure what the limit is for UWP apps though.
Amongst my secondary school friends, UCL was considered to be the better one. But they preferred Imperial overall.
I did Biochemistry at Imperial two years ago. You don't have to worry about lack of girls for Biochem - the split was probably about 40:60 in favour of guys. I think it's engineering, computing and so forth where you'll see a much larger proportion of guys. 

On my Fresher's Week, there were specifically events for people who didn't drink. Of course, not drinking does make it harder to make friends but I wouldn't be too concerned there :)
No worries. If you have any more questions just feel free to ask :)
You really should reply directly to comments, you know, otherwise people won't get notifications that you replied to them :)

And yes, that's one of the advantages. The software development principal you are referring to is *coupling* - how closely connected and interdependent your code is. Currently, your code is very tightly coupled. If you change one thing, it's likely that you'll have to change many other things to get your code into a working state again. By forcing yourself to unit test your code, you are also forced to write functions for your code. This reduces coupling - adding an extra function or changing an existing function is less likely to mean changing everything.
OP's code wasn't working because he was accidentally using Python 2.7 :)
Testing code, simply put, is about running your code under a specific scenario and checking that an expected outcome happens. There are many types of tests:

* Unit tests - tests around a "unit" of code (i.e. a single function or single class) 
* Integration tests - these test a whole group of code (i.e. a whole script or a whole process)
* Performance tests - these test that the code meets certain performance criteria (speed, memory, etc.)

and so on.

Unit tests tend to be seen as the most essential kind of test and in a professional setting they are pretty much mandatory. If you have a function such as the below:

    def add(num1, num2):
        return num1 + num2

then an example of a unit test for this would be the following:

    def test_that_add_1_plus_2_returns_3():
        assert add(1, 2) == 3

If `add()` works as we expect, then the test passes. If `add()` returns anything else, then an exception is raised and we fail the test.

Tests are desirable for many reasons:

* You can check that the code works without having to manually run the code - you just run the tests instead.
* If someone else looks at your code, they can very easily look at your tests to figure out what is going on and what is expected from the code
* If someone else looks at your code and they run the tests, passing tests gives them confidence that the code is working as expected.
* If you make a change to your code and the tests pass, then you have confidence that you haven't broken anything.
* Generally a better way of coding is TDD - test driven development. You write a test first, write the code to make the test pass and then alternate between the two. Often, TDD leads to better designed code.

Finally, when we write unit tests, it's a good idea to use a test framework. `unittest` is the testing framework that comes included in the Python Standard Library; however, I highly recommend you install and use `pytest`. Amongst other things, it will allow you to write simple tests like the one above.
Eh, yes and no.

Old-style super (`super(Coin, self).__init__`) only works if you inherit from `object` - i.e. if you are using a new-style class.

New-style super (`super().__init__`) is Python 3 only. In Python 3, all classes are new-style classes and automatically inherit from `object`, so it is redundant to explicitly inherit from `object` when you define your base class.
* There are some places where your indentation seems off - most notable near your while loops. Please fix the indentation here.

* Currently your code is one long stream of consciousness. I would highly recommend isolating your code into multiple functions.

* Have you unit tested any of this code? If not, I would highly recommend adding some.
I've run your code and it works fine for me. I can only echo the questions of everyone else - are you sure you are running Python 3? Type the below and see if you see 3 or 2.

    import sys
    print(sys.version_info.major)
Being able to take user input and print out text to the console are two of the simplest things in Python. In fact, they are probably the first two things I ever did. In short, you don't need to look for examples of this. Once you learn the two things above, just dive in and create your game.
Having the syntax for the list is unnecessary btw - you can have this:

    sum(x + y for x, y in zip(integers, fractions))
Even then, I'd still recommend learning Python 3 at home and just learning the differences between 2 and 3 for work.
So, you missed out this step in my comment:

> Since the input will be stored as a string, you'll need to cast it to an int.

Your program expects an int. If you give it a string, which is what you will get from `input`, then your function will fail.

You can convert from a string to int using the built-in `int()` function. I would recommend putting it around input like this: `int(input(''))`.
Functions aren't used just for code reuse. Chunking your code into functions makes it more readable - a reader can understand one function at a time rather than having to understand a large block of code in one go. Functions also lead to code that is more testable, which I'll explain in more detail below.

---

Testing code, simply put, is about running your code under a specific scenario and checking that an expected outcome happens. There are many types of tests:

* Unit tests - tests around a "unit" of code (i.e. a single function or single class) 
* Integration tests - these test a whole group of code (i.e. a whole script or a whole process)
* Performance tests - these test that the code certain performance criteria (speed, memory, etc.)

and so on.

Unit tests tend to be seen as the most essential kind of test and in a professional setting they are pretty much mandatory. If you have a function such as the below:

    def add(num1, num2):
        return num1 + num2

then an example of a unit test for this would be the following:

    def test_that_add_1_plus_2_returns_3():
        assert add(1, 2) == 3

If `add()` works as we expect, then the test passes. If `add()` returns anything else, then an exception is raised and we fail the test.

Tests are desirable for many reasons:

* You can check that the code works without having to manually run the code - you just run the tests instead.
* If someone else looks at your code, they can very easily look at your tests to figure out what is going on and what is expected from the code
* If someone else looks at your code and they run the tests, passing tests gives them confidence that the code is working as expected.
* If you make a change to your code and the tests pass, then you have confidence that you haven't broken anything.
* Generally a better way of coding is TDD - test driven development. You write a test first, write the code to make the test pass and then alternate between the two. Often, TDD leads to better designed code.
Use `input()` to capture user input, similar as above. Make sure that you store the inputted number in a variable. Since the input will be stored as a string, you'll need to cast it to an int. Then, you can call the function with this number.
A couple of suggestions from me:

* I think your game function is rather large and could do with being broken up.
* Do you have any unit tests for your code? If not I would recommend adding some.
repl.it does actually take in user input. I tried it just now and it works - you type the input into the repl once you run your program.

Try it out yourself - type the following program into repl.it, run it and you'll see the input prompt in the REPL:

    a = input('Type here')
    print(a)
Yup, Top Gear had been going downhill for a number of series before the Clarkson punch. 
How much of each have you watched? Both new Top Gear and The Grand Tour have improved with each series.
Address bar is still tied to Windows styles for unknown reasons... It's a shame, I really want to be able to theme the address bar in the themes I've designed, but there is currently no way to do this.
*by default*

The flag has been there for a year, the are only just making it default now, for weird reasons.
You don't have to climb anywhere if you don't want to. It's been shown you can complete the game with the true ending without climbing at all.
I think instead of `self.args = args if args else None`, you can simply do `self.args = args`. The second form works better with line `adjectives += self.args`.
That's a humongous if. And it's not just the top apps like Facebook and Snapchat that Samsung needs. It's all the bank apps and transport apps and media apps and restaurant apps and cloud storage apps and dating apps and God knows what else. And here's the thing - it only takes one app to be missing for it to be a deal-breaker for someone. It's as simple as "I don't have that one app that lets me log into my university portal" or "I don't have that one app that lets me connect to my workplace WiFi" or "I don't have that app that lets me order my favourite take-aways online" to make any one person return their phone in lieu of a phone that can do that thing.
The problem is that it's a chicken and egg scenario. Can Samsung get enough users before the apps arrive? Will there be enough users willing to give up an app ecosystem they've been using for years, just to use a Samsung device? As soon as people notice that their favourite apps are no longer on their new Samsung device, and that their favourite apps *are* on that other device in the phone store, people will drop Samsung like a hot potato.
Because Samsung's users were on a different platform?

Snapchat has to be there on Day 1. And Instagram and Facebook and Twitter and all the banks and transport apps and media apps and the list goes on. As soon as people buy the phone on Day 1, go to the app store and find that all these apps that they used for YEARS are suddenly not there, the refunds will start to pour in. Negative word of mouth will ensue and Samsung's advantage will go up in smoke.
As soon as they go to the Tizen Store and realise they can't install Snapchat, they'll definitely care.
The users are only there *because* of the store. Remove the store and the users will disappear.
Because:

* It's extra effort for Nintendo to do. Such things are not free to implement
* It's likely not worth it; Wii U owners already have a GamePad, why do they need another one?
* Not all features would work. Switch lacks the IR sensor and the camera. Many Wii games would not work for this reason.
* Nintendo wants to make a clean break from the Wii era, and *especially* from the Wii U era. This would not help that.

Go to chrome://flags, scroll down to Custom-drawn Windows 10 Titlebar and press Enable. This will enable Windows 10-style titlebar buttons.
Yes you will have to. There's a file called manifest.json. This has a mapping of Chrome themable areas to files, colours and so forth. Wherever you see an "old" file path in manifest.json, you need to replace it with the new file path that you specified.
Apologies about replying to this late, but I have quite a bit of experience developing themes so if you require any help, I'm happy to assist.
The "Mail links will only open in Edge" thing is *super* disappointing. Like, really really disappointing. The worst thing about it is the hypocrisy. How can I believe that Microsoft actually cares about user feedback when they pull moves like this?
There are *definitely* examples of Google doing similar things. Example - if you want to use Google Hangouts as a desktop application instead of using a website, you have to have Chrome installed, you have no other choice. And then if you want to open a link from the Hangouts app, it will open in Chrome, it won't open in your default browser.
Why on earth would Microsoft need to astroturf Windows Defender? Windows Defender is both free and inconspicuous by design - astroturfing such a product makes no sense.
Chrome themes are very limited in what they can do. Theme developers have no way of changing menu colours.
Surely the latter, right? If it was only the former, then groups of people would go to restaurants just to socialise and not to order anything. I think that scenario is weirder than only one person going to a restaurant and ordering food.
I think McD or Burger King is different to "proper" restaurants - almost everyone has gone to one of those alone at some point.
A beginner who doesn't know what `eval` does won't understand the problems with it. So no, it doesn't accomplish the same.
... And because you are a beginner who doesn't understand why using global variables are a bad idea and because you don't know how to structure your code to avoid them. This happens to many beginners, myself included when I was starting out.
It's a reference to Jeremy Clarkson and Top Gear. Jeremy Clarkson, one of the presenters of BBC Top Gear, punched a producer because there was no hot meal for him at a hotel during filming. The BBC refused to renew his contract because of this. Clarkson and the other presenters, Richard Hammond and James May, plus the executive producer of the show, Andy Wilman, all left Top Gear. They started their own production company and created a replica show, The Grand Tour, which Amazon bought the rights to for three series.
No, using `global` is almost always the wrong move. `Xold` and `Yold` should not be defined in the global namespace if they are to be modified. Instead they should be passed into the function as arguments. An example would be this:

    def calculator(Xold, Yold):
        ...

    def main():
        Xold = 0
        Yold = 0
        calculator(Xold, Yold)
        

    if __name__ == '__main__':
        main()
It is indeed possible to access a base class method from within the subclass. You use the `super` function to do it.

    class animal:
        def age(self):
            return 5

    class dog(animal):
        def age(self):
            return super().age()     # returns 5

I think this is what you want, there's a little ambiguity between your title and your description so I'm not sure.
The reason, especially when starting out, is simply because it's easier. When you are learning programming for the first time, having to learn a new editor on top of that is an additional cognitive load and it's distracting. Even now, having learned Python for a year, I'm trying to use Vim as my editor but having to relearn how to do everything I want to do is a pain when I just want to code. So, I'm spending half my time on Vim and then the other half on Notepad++, the latter where I am far more productive for now.
Having seen inexperience Emacs users in my Bioinformatics class, I can assure you that they *definitely* struggle with it! Most of the people learning how to code, myself included, preferred to use either Notepad++ or Gedit to Emacs, simply because they were far more comfortable with the former. 


With regards to unit tests, there are various tutorials around. For example, there's a nice Python one on Pluralsight that I used to get myself knowing how to write them correctly.

Your idea is interesting, but the only problem is that it encourages you to write the tests after code has been written. Which is fine, but it's not the best way and I think you might have better results if you simply try to have a go writing tests as you do a project of some sort. That way, you can practice TDD (test-driven-development) - the art of writing a test first, writing the code to pass that test and then iterating over that process again and again.

The rent price, is that for the whole 3 months or per month?

From gut feeling, £800-900 per month (assuming three months to get a job) seems low.
Can you convert to GBP? I'd do it but I'm too lazy XD Once you do that, I could help you out.
It's tricky. 

18-21k for software development job is peanuts, make no mistake about it. Think about it like this: currently the payment threshold for tuition fee loans is £21k. This is the level at which the government thinks that you've benefited enough from university that you can start to pay back your loan. Your projected salary is exactly £21k, so your salary is not being considered as good enough - you haven't benefitted enough from uni.

Usually, I would tell someone to skip this job. I would be worried that they aren't valuing your skills at the right level, which may indicate deeper problems. However, it's taken you a year to get a software developer job offer and another opportunity may not come around so easily. Given that fact, I would lean towards taking the job but looking for other jobs immediately.
I'd recommend not using a list comprehension here. List comprehensions are great, but when you have more than 2 statements in your comprehension, they get hard to read. I would highly recommend trying to use a loop instead, it will make your code easier to read and help you figure out where you are going wrong.
Yup, precisely. And you would use instance attributes that you define using `__init__()`, not class attributes.
Oh yeah, I didn't even notice that, you're totally right. OP should be iterating over `contents` itself rather than using that code.
The main problem is the usage of the `global` statement. 99% of beginner usage of `global` is incorrect; here, `contents` should be passed in as a parameter, not fetched using the `global` keyword.

Personally, I'm more concerned about [this snippet of code](https://i.imgur.com/oYzWruQ.png). It shows that OP has no idea on how to use classes.

It's a shame, because I commend OP on trying to make something educational. But the other commenter is dead right; this code has issues and will set other people down the wrong path.
I see quite a few things in your code that is not recommended. Could you link us to your code? I think that it could be improved somewhat.
Imagine you want to write a script to add together two numbers, and then multiply the result by a third number. So, perhaps you start by defining two numbers and a function to add them together. Something like this:

    a = 1
    b = 2 

    def add(x, y):
        x + y

Now the question is: you need the result to do the multiplication with, how do you get the result out of the function? 

It's at this point that beginners who don't understand how functions work will Google the `global` keyword and end up writing something like this:

    a = 1
    b = 2 

    def add(x, y):
        global c
        c = x + y

    add(a, b)
    print(c)        # 3

You should never write code like this; there are many reasons why you shouldn't, most of which are outside the scope of your question. The way to get the result is to use `return`. `return` lets us save the result of the function to another variable:


    a = 1
    b = 2 

    def add(x, y):
        return x + y

    c = add(a, b)
    print(c)        # 3

That's all `return` does, simple as that.
I think there are probably places in your code where it would be better to use a class than to use functions all the time. The thing is knowing when to do procedural style and when to do OO style, and knowing when to switch from one to the other is not always simple. A good rule of thumb is that, if you find yourself passing in and returning the same data over and over again to many different functions, then it's a good time to use a class instead.
Firstly, this is more of a question for /r/learnpython .

It's important to understand exactly what `dict.items()` does - it gives you a iterator of tuple pairs containing the key and value for each item in your dictionary:

    >>> a = {'month': 'march', 'year': '2018'}
    >>> list(a.items())
    dict_items([('month', 'march'), ('year', '2018')])

The reason your first example works is because `b` has the same tuple that `a` has. Both have the tuple `('month', 'march')`:

    >>> a = {'month': 'march', 'year': '2018'}
    >>> b = {'month': 'march'}
    >>> a.items()
    dict_items([('month', 'march'), ('year', '2018')])
    >>> b.items()
    dict_items([('month', 'march')])

Now look at your example of lists:

    >>> c = {'months': ['march', 'april']}
    >>> d = {'months': ['march']}
    >>> c.items()
    dict_items([('months', ['march', 'april'])])
    >>> d.items()
    dict_items([('months', ['march'])])

Python only checks for equality on the top-level when you use = and <= . It doesn't check for equality lower down. It sees `('months', ['march'])` and `('months', ['march', 'april'])` and says that they aren't equal to each other, because they aren't. Because of this, if you do `d.items() <= c.items()`, it will return `False`.
Like I said, mostly those on 2.7 are companies, universities and the like. But the split is only for legacy reasons and only because 3 is not backwards compatible with 2. There's no argument in the community as to which version of Python is better - literally I've heard only one person argue Python 2 was better and no one else agreed with him. There's also no argument as to which version of Python is the long term version. The company I work for are notoriously slow to upgrade anything, and we've been using Python 2.**6** for the last ten years. But, they've announced that the focus for 2019 is Python 3 and a lot of funding will be spent in that area.

As for getting up and running, Python is actually pretty simple to get started with. I'd hugely recommend to use Anaconda, especially if you are on Windows. It's one .exe to install and you have Python installed with virtually every popular third-party package included.
Definitely Python 3. At this point, the only main reason to learn Python 2 is if you are forced to (e.g. it's what your uni or job uses). In almost all other cases, you'll want to learn Python 3.
Trying to explain OOP in a way that's meaningful is tricky. I'll try to give you a short answer to your question below. If you want a longer answer, I can provide a comprehensive one, but it will take some time to really explain, especially if you are not a programmer and don't understand basic programming structures.

Object-oriented programming is a style of programming where you group data and related code together into one package, typically known as an object. It's a way of structuring and organising the code that you write, and it leads to code that is very reusable.  

An alternative to OOP is procedural programming. Here, you define functions - logical groups of code. You then pass data into functions, and you get transformed data out of your function. Your data is not associated with your code; the two are independent. 

Though both styles lead to reusable code, OOP tends to be better at doing this, especially if your code is going to work on the same kinds of data over and over again. On the other hand, you have to use more syntax to create an object than to create a function, and you don't always get any benefit in return. In places where it would be overkill to use objects all the time, procedural programming will lead to simpler code that is easier to read.

Java tends to be seen as *the* OOP programming language. This is because it forces you to write ALL your code in this style. On the other hand, if you want to be able to write in either style, something like Python is better to learn. Python lets you create functions and objects and you choose which style fits the current situation.
Advertisements are basically the only way that most websites can cover their cost, and hence they are a necessary evil.
Windows 10 S Mode is exactly that - a mode. You can switch it on and off freely. Impact to gamers is zero. Also, the switch is likely to be off by default if you are purchasing a retail copy of Windows 10, like many PC gamers will be if they are building their own PC.
> Unix is a watered down version of Linux

You do realise which one came first, right?
Three finger swipe is great if you use your phone with two hands, but nigh on impossible if you use your phone one handed.
> iOS (and other Android OEMS)

Actually, my Nokia 8 has this feature too. It's *so* nice, first time it happened for me was with the update from Nougat to Oreo. It tricked me into thinking  the update must've failed because I thought there was no way it could have rebooted so quickly and succeeded, yet it did.
Never said I object to people blocking them - you just assumed that. I just don't want people to be disingenuous about *why* they block ads. If you admit you block ads because you don't like them, that's fine with me.

As for my own personal opinion, there's no doubt that a lot of ads are god awful. Just terrible. But, without ads, a lot of web content would simply not exist. No one has come up with a alternative model, other than paywalls, and who wants paywalls everywhere? 

Chrome's ad blocking is something that I support and use. Block the intrusive ads but let through ads that are non intrusive, to ensure I continue to support the sites that are doing it right.
The whole point I use Spotify is because I want to listen to music legally and ensure that the artists are getting compensated for their work. I don't understand why people *want* to use Spotify just to listen to music free without any payment/ads. If I was going to do that, I'd just pirate and download all the music I want and ignore Spotify completely.
The main reason why the vast majority of people block ads is because they don't like ads. Most people are not tech-savvy enough to know about the link between ads and malware. Out of those people that do know about this, quite a lot of them would block ads regardless of this link, but the malware thing is a convenient reason to use while not having to say the main reason they use adblocking - because they don't like ads, of any type.
Round 1485 of mental gymnastics where people who pirate media come up with reasons to justify their piracy rather than just admit they don't want to spend money. See also: ad blocking.
Yes, but let's not encourage beginners to use the global keyword. They never know how to use it correctly.
The problem is the print function is within the if block, so it only gets run if you enter age between 5 and 130, and it NEVER gets run if you have it after the break. You need an else:

    while True:
        age = eval(input("Your Age (between 5 and 130): "))
        if 5 <= age <= 130:
            break
        else:
            print("An invalid age was entered. Please try again.")

    print("Thank you. You are %s years old." % age)

Also, that use of eval is the worst. Replace it with a call to int instead:

    while True:
        age = int(input("Your Age (between 5 and 130): "))
        if 5 <= age <= 130:
            break
        else:
            print("An invalid age was entered. Please try again.")

    print("Thank you. You are %s years old." % age)
I don't think the legality of it is too much of an issue, more that they've got to make it play friendly with all the proprietary stuff from a technical perspective.
There's a good Pluralsight course on Python Unit Testing, if you are willing to pay for the subscription.

I guess, if your function seems too complex to test then there is one of two options

* Split your function into smaller testable functions
* Use mock to mock out certain pieces of your code. For example, in the function that calls for files to be deleted, you'd want to mock out the call to delete when testing the function.
Eww, camel-case method names! This project is terrible!

... Just kidding :3 But next time, perhaps consider using snake-case for function names?

Also, your code looks pretty good, but do you have any tests for it?
I initially took it as an off hand joke, but then I heard people laughing in the background and that immediately made me think of Zed.
It's a little harder where I work, they have a very large and very proprietary code base. Just introducing a new module takes months to do. Still, we've finally moved to Python 2.7 this year so there's always hope :3
I'm forced to use unittest because it's what we use at work. But having used pytest, I genuinely can't think of a single reason I'd want to use unittest over it.
Your `main` function is broken because the line `x1 = int(input('Enter a number: '))` is not indented and so is not within the scope of the function.

It needs to be like this:

    def main():
        x1 = int(input('Enter a number: '))
        return x1

Also, as an FYI, `main()` is, by convention, the first function that is called in a script. Other functions should not be calling your `main()` function, it's the other way around.
Take the simplest function you have and try to apply the above techniques to write a unit test for it. If you find that all your functions are too large or complex to write tests for, it's a smell that perhaps you need to break your code up into smaller functions that you can test easily.

One last thing - usually people do testing with a test framework. The one in the Python Standard Library is unittest, but I would recommend testing with pytest instead. The tests are much easier to write for a beginner as there is almost no boilerplate code involved.
Testing code, simply put, is about running your code under a specific scenario and checking that an expected outcome happens. There are many types of tests:

* Unit tests - tests around a "unit" of code (i.e. a single function or single class) 
* Integration tests - these test a whole group of code (i.e. a whole script or a whole process)
* Performance tests - these test that the code certain performance criteria (speed, memory, etc.)

and so on.

Unit tests tend to be seen as the most essential kind of test and in a professional setting they are pretty much mandatory. If you have a function such as the below:

    def add(num1, num2):
        return num1 + num2

then an example of a unit test for this would be the following:

    def test_that_add_1_plus_2_returns_3():
        assert add(1, 2) == 3

If `add()` works as we expect, then the test passes. If `add()` returns anything else, then an exception is raised and we fail the test.

Tests are desirable for many reasons:

* You can check that the code works without having to manually run the code - you just run the tests instead.
* If someone else looks at your code, they can very easily look at your tests to figure out what is going on and what is expected from the code
* If someone else looks at your code and they run the tests, passing tests gives them confidence that the code is working as expected.
* If you make a change to your code and the tests pass, then you have confidence that you haven't broken anything.
* Generally a better way of coding is TDD - test driven development. You write a test first, write the code to make the test pass and then alternate between the two. Often, TDD leads to better designed code.
Very good effort, well done!

If I was to provide one critique of your code, it's that your functions are very long and there is a lot of repeated code. Consider breaking your functions up into multiple other functions.

Also, do you have any unit tests for this code? It may be worth adding some.
That's an odd distinction to make. When you present strings to the user, you usually don't display them with the quotes. So why should it matter which you use?
Have you done lists yet? Would [1, 2, 3] make sense to you?
The way I would do it would be to have a dictionary that maps dates of the year to the number of steps contained within each line of your file:

    d = {
        datetime.date(2018, 1, 1): 2306,
        datetime.date(2018, 1, 2): 5868,
        ...
        }

Such a dictionary is easy to create using iteration and a for loop. You wouldn't need to hardcode it.

Once you create it, then you could iterate over the dictionary, only pick out the dictionary values corresponding to one month, and sum those values.

Have you done dictionaries and datetime? Then use the above. If not, I can give you another solution.
This is your function:

    def function(x):
        print(x)
        print("is the argument")
        return 2*x

The first two lines within your function are `print` functions. It is these lines that are printing to the console. The `return` statement has nothing to do with what is being printed out to console.
`return` does not print anything to the console. This doesn't mean that `return` isn't being executed. Your `return` line *is* being executed. The fact that `a` is equal to 2 is proof that the `return` line was executed. This is what `return` does.
I can understand why someone wants to use grep and sed and awk and so forth. But now that Windows 10 has Bash shell out of the box, you can have those command line tools on either OS. So I really scratch my head as to why people say Linux is better than Windows when talking specifically about programming.
It's important to know what `return` does. All `return` does is ensure that the value of `function(1)` gets bound to your variable `a`. It does nothing else. 

To make inline text appear as code, surround your text with backticks (like \`this\`).

To make block text appear as code, prefix each line in the code block with four spaces.
The reason is to do with the immutability of ints (vs the mutability of lists).

In Python, variables can be thought of as references that point to an object in memory. So, in your example, `a[0]` is a reference and points to an int object of value 1. Something like this:

    a[0] --> 1

Inside the for loop, the int object then gets assigned to the reference `x`. At this point, you have two references pointing to the same int object, kinda like the below:

    a[0] --> 1 <-- x

Then, in your for loop, you do `x += 1`. Or, put another way, `x = x + 1`. However, as I said before, ints are immutable. They can't be changed. Instead of updating the int object from 1 to 2, what happens is that a new int object is created and then the reference `x` is updated to point to this new int object. What we then have is a situation like the below:

    a[0] --> 1
    x --> 2

As you can see, what the list element `a[0]` is pointing to is still 1. It's unchanged. Because of the immutability of ints, you can't update a list in this way.
Here's the thing, for me I can't see why the second option wouldn't work fine. For example, if you have a script like the following:

    frames = [[] for i in range(3)]
    
    images = [1, 2, 3]
    
    for x,y in zip(frames, images):
        x.append(y)
    
    print(frames)

then `frames` will be `[[1], [2], [3]]`.
So, I'm a little confused at trying to understand the below code:

    frames = [None] * len(cameras)

    # capture images until number of frames is reached
    while len(frames[0]) < frame_count:
	    images = capture_images(cameras)

	    for i, image in enumerate(images):
            frames[i].append(image)

I'm confused at:

* What `frame_count` represents
* How `frames[i].append(image)` can work when `frames` is a list of `None`s.

Perhaps you could elucidate?
If you need to do a binary search, you should really just use the `bisect` standard library module rather than trying to implement it yourself, unless you have a specific aim of implementing a binary search algorithm.
> Developing on a Unix-like system is *way* nicer than on Windows

I keep hearing this but I'm not sure why this is the case. I've programmed on Windows and on Red Hat and there wasn't really anything that I missed going from one to the other. Now that Windows 10 has a proper Bash shell, this is even more of the case. What does Linux have that Windows currently doesn't, programming wise?
They did say it was the last episode of the series at the beginning of the episode.
It's more common than you'd think. For example, at my job's fair, a few software companies said they are happy to take on physics graduates. I think the attitude is that if you have the right kind of analytical skills and attitude, you can do well in the job.
Main thing I would say is try not to use global variables. Where you have global variables such as `registered_horses` and `wild_horses`, you should probably remedy this in the following ways:

* Passing these variables in and out of functions explicitly.
* Having a class to take care of these functions
Google "Python code golf" for many more examples of these :)
I think most people in here would recommend for you *not* to get the 6P. Battery and bootloop issues have spoiled what was a really good phone for me. Plus, I imagine the 6P will cease to get any more feature updates soon. As an owner of the Nokia 8, I would advise you to get that or to get a OnePlus 5T.
Jupyter is definitely not an IDE you want to be using, IMO. The only time you really want to be using it is for the Jupyter Notebooks.
Start with any functions/classes that don't require you to connect to an external resource. The simplest kind of unit test is where you give an input to a function, run the function and check that the output you get is equal to what you expect. I'd recommend using the pytest module in order to perform your unit tests.
Looks like a pretty cool project! Code looks good too. I can't see any unit tests for your code though, perhaps you could consider adding some...?
I guess the problem is with one of the rooms you've coded like this, where lock is modified outside of the `if exit` block.
    
    elif chosenPath == "Nursery":
        print("You open the door and...")
        time.sleep(3)
        print("You notice many broken baby cribs all around the room.")
        lock = True
        if Exit == 4:
            print("You found John! He's unconscious but still alive. Time to head for the exit at the end of the hospital.")

If you enter this room but `Exit` doesn't equal 4, you'll open the lock but you won't rescue John. As a result you can exit without going into one of the later rooms and without rescuing John.

As an aside, you could really do with refactoring this code. There's a huge amount of repetition in your code and there's a huge reliance on global variables. This makes your code extremely difficult to read and understand. If you break your code up into reusable functions and remove the global variables you are using, you'll make your code so much easier to read.
In that case, I think you pretty much have all the main stuff. I can't think of anything else off the top of my head that you would really really benefit from having.
I see Github, I assume you use Git for version control then?
Whilst your solution is correct, I don't think it's best encouraging beginner Python writers to use `global`. It's a common novice problem - gratuitous usage of `global` when no global variables should be used.
It's important to know the difference between global and local scope. When you create a variable outside a function, it has global scope (it can be accessed from anywhere in your module). When you create a variable inside a function, it has local scope (only accessible within the function).

Now we have the line:

    usernames = usernames + nuser

Personally I'm surprised this doesn't work - I'd think that this line should work   (ignoring the TypeError) because you are taking the global variable `usernames`, adding something to the object, and then assigning it to the local variable `usernames`. I think, due to the deeper workings of Python, it doesn't like both global and local variables of the same name and so throws this error. I'd be interested to know why.

Anyhow, if you rename to:

    usernames_local = usernames + nuser

or rename to anything else, it should work. Well, actually it won't because there is also a TypeError in this line due to your script, but that's for you to figure out :)
As someone who got into a financial programming as a first job having graduated with a science degree, I feel this question is mine to answer :P In short, if you have a good enough track record, companies are willing to take a punt on you. What did it for me was a great degree from a top 10 uni worldwide, plus good competency interview performances.
What about computers do you like? There's many jobs other than programming: hardware engineer, sys admin, tech support, etc.
This line is wrong:

    input == input()

You are using two equals when you want to use one equal, since you want to do assignment and not equality. Also, while we are here, make sure you give your variable a name other than `input`. If you assign anything to `input`, you will mask the builtin `input()` function. In this script, it doesn't matter, but if you had a script that used `input()` multiple times, you wouldn't be able to use it again after the first time.

Change your line to this:
    
    in = input()
[There is a Chrome extension to bring it back too.](https://chrome.google.com/webstore/detail/view-image/jpcmhcelnjdmblfmjabdeclccemkghjk) Perhaps you could have linked to this one instead, given you are in /r/chrome? Or are you so obsessed with proselytising your favourite browser that you just had to link the Firefox extension instead?

EDIT: You don't even need to install the above. Right-clicking the image and selecting "Open in new tab" does exactly the same thing.
In my opinion, this is normal when you consider the below:

* People are good at different things.
* You've been learning math and science far longer than you have programming. While you are learning advanced concepts of the former, you are learning basic concepts of the latter.

Keep at it and look at Java resources online to help augment your learning.
Chromebooks aren't crippled devices. Simple != Crippled. What you lose in functionality compared to full fat OSs, you gain in simplicity and extremely low maintenance.
[You're replying to a copypasta.](https://www.reddit.com/r/circlejerkcopypasta/comments/2ceq3u/heres_the_thing_you_said_a_jackdaw_is_a_crow/)
For loop is the way to do it - you've got the right idea. List comprehension is also another way.
Use namedtuples if the data attributes don't need to be changed (remember that you can't edit a tuple once created, and namedtuples are the same). If the data attributes are to change during the course of your code, then use a class
Why do you need `path = str.encode(vag)` ? You should just be able to pass `vag` into `os.walk()`.
The problem is it's tricky to know what's best for someone, as different learning resources suit different people better. I can tell you what worked for me - the Pluralsight "Python Fundamentals" and "Python Beyond the Basics" courses. The only catch is that a Pluralsight subscription is pricy, and there are plenty of free resources out there.
There are plenty of learning resources in the sidebar - you should check them out.

I hope you enjoy not having to write classes for everything, as well as being able to do:

    print('Hello World!')

rather than:

    public class HelloWorld { 
        public static void main( String[] args ) { 
            System.out.println( "Hello World!" ); 
            System.exit( 0 ); //success 
        } 
    }
It's pretty difficult for us to know without seeing the input file. Simple debugging should point to the issue - print `user` and `password` and inspect them to see if they are what you expect.
It's a Disney movie - don't try to analyse it too hard :P

For me, the biggest plot hole is that Hans tell the Duke and dignitaries that Anna died, and he and Anna said their marriage vows before she died, *and then the dignitaries just accept that*. 

Why does no one else verify Anna is dead? And why does no one question how Hans can marry Anna without witnesses or even so much as someone to perform the ceremony? It makes no sense!
... probably because of the messages they get from society? The societal messages are that guys who pull lots of girls are cool, and that guys who never have girlfriends or are virgins into their twenties are not cool and are possibly even weird. I agree with yourself, defining yourself by your sex life is pretty unhealthy, but when you are in that position it's difficult not to do it when that's the vibe you get from society.
You've indented your print function one level too many. It's under the `else` block, so you only ever print when you enter the `else` block (i.e. when input is 12 or greater).

Dedent your print function to make it work correct.
Most likely trying to get people to change their gas or electric companies. When I was younger, I remember salesmen knocking on the door every now and then trying to sell energy. These days, I don't see them any more, most probably because they've been made totally redundant by price comparison websites.
The file extension should be .xlsx , not .xlxs.
Thank you very much :)
It's important to know about references and objects to understand this properly.

This is what `Player1.name` looks like before you pass it into your function:

`Player1.name` -> 100

`Player1.name` is a reference to the object 100.

Now we pass it into the function. When you do this, you are assigning a new reference to the object - that of the `money` parameter. The object now looks like this:

`Player1.name` -> 100 <- `money`

But then, when you do `money = 200`, the `money` reference is updated to point to an object of 200 instead. So this is what you end up with:

`Player1.name` -> 100

`money` -> 200

This is why Player1.name is unchanged. This can be a little confusing to understand at first - I highly recommend Googling "Python pass-by-reference" to understand this concept fully.
The problem is global variables turning into variables that are only local to the function.

This is where you pass in `agility` (or any of the other stats):
    Stat_Mod_Bstory(agility, bstory_op_A_S_R_PT)

And this is your function definition:
    def Stat_Mod_Bstory(stat_def, bstory_op_def):

What's happening is that your `agility` argument, which is a global variable, turns into the `stat_def` parameter, which is a local variable whose scope lives within the function only. At this point, `agility` is no longer modified.

There are two main ways of doing this, the `inexperienced beginner way` and the proper way.

Inexperienced beginner way: return `stat_def` in your function to ensure `agility` continues being updated. 

Proper way: get rid of the global variables! You should never be using global variables. Put your stats into a data container of some sort and then pass them into the functions that modify them. Since you want to modify these attributes, the best choice is a class.

This is how to do it with a class:

    class Person:

        def __init__(agility, strength, reflex, pain_tolerance):
            self.agility = agility
            self.strength = strength
            self.reflex = reflex
            self.pain_tolerance = pain_tolerance


    def main():
        person = Person(1, 1, 1, 1)
        person.agility += 2
        print(person.agility, person.strength, person.reflex, person.pain_tolerance)
        # prints 3 1 1 1
Oof, that is a lot of global variables right there. I would hugely suggest for you to refactor your code to remove the global variables. Trust me when I tell you that you don't need them, and that they are not conductive to good code design. While you are at it, I would also refactor your code so that you don't call functions in the global namespace (you should only call functions within other functions), that you start your variables with a lower case letter (only classes start with a capital letter) and that you find some way of removing your "list_maker" functions.

You pass Player1_money into BUY_OR_PAY like so:
  
    BUY_OR_PAY(Player1.name,Player1.position,Player1.properties_list,Player1_money, ... )

And then here is the beginning of BUY_OR_PAY:

    def BUY_OR_PAY(player, position, properties_list, money, owner, price, category):
        global Player1_money
        global Player2_money
        global Player3_money
        global Player4_money

The `Player1_money` argument is passed into BUY_OR_PAY as `money` parameter. At this point, because you are dealing with the `money` variable inside BUY_OR_PAY, you are no longer dealing with `Player1_money`. So it is irrelevant that you have made `Player1_money` global as that variable is not changing at all.

The hacky, terrible way to fix it would be to do something like:

    def BUY_OR_PAY(player, position, properties_list, money, owner, price, category):
        global Player1_money
        Player1_money = money

and then continue to refer to Player1_money in your function.

The actual way to fix this is to stop using global variables in your code. Part of the reason to stop is that it leads to messy code, as evidenced here.


That's a shame, WP was a really great OS crippled by a lack of app support. A number of techies were attracted to Windows Phone. More went to Android, but then more people in general went to Android. 
You could literally be describing Windows Phone there, instead of Meego.
I have a Nokia 8 - it's great! And now it has just gotten Android 8.1 and it's even better XD
Why would Meego have worked instead of Windows Phone? Seems to me both would have suffered the exact problem - lack of apps.
Perhaps try an AI that can play tic-tac-toe. It's not the most fun of games, nor is it the most original of projects, but it should be something within your grasp.
The string format is only working on the last string, simply because that's the only thing you applied it to.

There's two ways of solving this:

    print_str = ("Here are some numbers, the first is {0:d}, "
        "the second is {1:.2f} and the third is {2}")
    print(print_str.format(12, 3.14, 5))

Or, if you are in Python 3.6, the below should also work:

    print(f"Here are some numbers, the first is {12:d}, " 
        f"the second is {3.14:.2f} and the third is 5")

Remember three things:

* Within brackets, you have implicit line continuation. No need to use \ for line continuation.
* Adjacent strings will auto-concatenate. No need to use + for concatenation.
* In Python 3.6+, use f-strings as much as possible. They are awesome.
This is not what you should be thinking of when you write code. Any opportunity you have to abstract a logical block of code away into a function, you should take. Generally speaking, the more functions you use, the better.
Lots of unbranded Nokia 8 phones took ages to get the 8.0 update. My Nokia 8 took something like 5 weeks to get it. When you put in a SIM, somehow it becomes linked to that carrier. All the Vodafone UK devices got it 5 weeks after Nokia started the rollout.

It's weird because it took me 5 weeks to get the 8.0 update, but I'm getting 8.1 immediately.
Do you need a new phone or not? If yes, buy the Nokia 8. If not, then don't. If you always wait for new devices, you'll be waiting all the time.
It's so odd, it took them something like 5 weeks to roll out 8.0 to my device, yet here I am getting 8.1 immediately.
You should keep it as lower case since f is probably not a constant here. What pylint is telling you is that you should be instantiating `Foo()` within a function and not as a global variable.
Exponents are really easy in Word. You just type 3\^4 in the equation, hit space and it will format as 3^4.

I'm not sure about searching for symbols though. Like you, it's been a while since I used Word's equation support.
You don't, Microsoft still sell standalone versions of Office.
I feel like Word gets a lot of undeserved hate for its equation software. No, Word isn't at the level of LaTeX, but Word's equation software is actual pretty good once you learn how to use it. The key is to use the mouse as little as possible - if you are using the mouse to create complex equations in Word, then you are doing it wrong and you are absolutely going to hate it.
If we are talking about money, I'm pretty sure that where Python loses in terms of energy costs, it wins in terms of developer cost. Developers can code a solution in Python often quicker than they can in other languages, which means employers are getting more value for the money they pay out to developers. I'm pretty sure that money is one of the reasons Python has gained a lot of traction in companies.
collateral
Try this:

    attributes = ['employee_name', 'employee_email', 'employee_address']
    for attribute in attributes:
        getattr(form, attribute).data = employee_info[attribute]

Adjust the attributes list for how many employee details you have.
I would iterate over the items of the old dictionary and conditionally add them to the new dictionary.

When adding an item to the new dictionary, you check to see if the text already exists as a key in the second dictionary.

If it doesn't, you add the text as a new dictionary key. Your new dictionary value is a dictionary itself, where you set the count of that dictionary to be one and the IDs to be a list containing the id.

If it does already exist, you simply update the count and the list of IDs in the existing new dictionary value.

If you want to take this further, you could also use defaultdict as part of the solution.
If the superclass `__init__` requires 6 parameters, then you have to give it 6 parameters. I think you don't need to override the superclass `__init__` at all, you can use the same `__init__` without any modifications and it should be fine.
Next time around, I recommend looking into the 2to3 module if you want to convert Python 2 code to Python 3.
As someone with a Nokia 8, go do it! The phone is exceptional.
Do you have a link to the article, or remember where it was? sounds like an interesting read.
You will have to use debugging tools (either within your IDE or use the pdb package) in order to figure out the issue.

I also suggest refactoring your code to improve it to reduce the chances of bugs, to make it easier to understand what is happening and to change/improve it if needs be. For example, you are using a lot of global variables when you probably don't need any - you should change this.

I'd also recommend adding tests to your code - this will provide confidence that your code works ok and will help point to any issues if it does not.
Much has been said on why global variables are bad. Instead of adding to that, it's better for you to read this thread [topic](https://softwareengineering.stackexchange.com/questions/148108/why-is-global-state-so-evil).
I think that you will need to include your year's teaching on your CV. A gap of a year will look suspicious to any prospective employer.
You are only writing the header of the receipt into a file, and then printing everything else out to the console. You need to write every line of the receipt to the file.
The script is very well done, you should be happy with the result! That said, you've done my pet peeve in this script - the if-elif ladder:

    if choice == 0:
        sys.exit()
    elif choice == 1:
        money_hack()
    elif choice == 2:
        switch_mount('Horse Regular')
    elif choice == 3:
        switch_mount('Warhorse')
    elif choice == 4:
        switch_mount('Stag')
    elif choice == 5:
        switch_mount('Bear')
    elif choice == 6:
        switch_mount('Unicorn')
    elif choice == 7:
        switch_mount('Reindeer')
    elif choice == 8:
        switch_mount('SpookyHorse')
    elif choice == 9:
        god_mode('true')
    elif choice == 10:
        god_mode('false')
    else:
        print('Something went wrong.')
        sys.exit()

Whenever you have an if-elif ladder, consider abstracting away the relationship between the condition and the outcome into a list or dictionary. Unfortunately, I'm a little busy right now to type out the entire solution, but if you need extra help regarding this, do PM me and I'll explain further later.
There's no right or wrong answer here, it just depends on the length of the main file. For OPs file, it's 300 lines so it would be fine in the main file. Good a longer script, it should be moved to a separate file.
Google don't really care though. If they cared, they'd make all the Android code GPL. But they don't.
I see you haven't got a very modular design - your code is just one long stream of consciousness. Why not start to modularise your code by splitting it into functions? As you do that, you can think about moving some of your loops into functions so that you avoid code that is 5 levels deep.
`class ClassName(object):` is only important in Python 2.

In Python 2, you have old-style classes and new-style classes. New-style classes have more functionality, but in order to use a new-style class, you need to inherit from `object`. If you don't, you'll be using an old-style class.

In Python 3, the only type of class is a new-style class, and all base-classes automatically inherit from `object`. Which means that `class ClassName:` and `class ClassName(object)` are exactly the same, the latter being redundant.
Ok, I see the redundancy in the for loop. This should be better, no?

    for x in ops:
        print(f'{x}: {ops[x]}')

That should be ok, no?

---

> Secondly, in the class example you gave, the \_\_init__'s arguments (other than the inv list and the hp value) aren't assigned to the classes attributes.

OK, I see what you mean. Will fix.
Hey there - some feedback on your code.

---

You shouldn't assign attributes to functions (like `player.hp`, `player.str`, etc). In beginner code, it's always a code smell that you aren't doing things correctly. You haven't gotten used to passing items into a function in order to use them. Instead, you are using function attributes as a replacement for global variables, which is not a good idea.

What you should do is use a class to contain these values. This is the best long term solution. If you haven't used classes before, I would recommend looking them up. Your solution will initially look something like this:

    class Player:

        def __init__(self, hp=100, str=10, int=10, inv=('HP Potion', 'Mana Potion', 'Rope')):
            self.hp = hp
            self.str = str
            self.int = int
            self.inv = list(inv)

You then create an instance of a class, like so:

    p = Player()

And then you can pass this instance explicitly into any function, where you can refer to it and use it. Here's a very simple example of this:

    def change_hp(player):
        player.hp += 10
        print(player.hp)        

    change_hp(p)        # prints 110


---

Your dialogue function is far too long. I strongly recommend that you split it up into multiple functions by refactoring. This will make it easier for people to read your code and understand what's happening.

---

Within your dialogue function, I see what I like to class as "if-elif ladders". These are blocks of code that contain many if statements. These are quite unsightly and also not very reusable or maintainable. Almost always, there's a better way. Take for example, this particular ladder:

    if 1 in ops:
        print("1: Regular Option")
    if 2 in ops:
        print("2: Stat Check Option")
    if 3 in ops:
        print("3: Item Check Option")
    if 4 in ops:
        print("4: Quest Check Option")

You can make this much nicer by using a list or a dictionary. In this particular case, since you are using numbers, it's better to use a list:

    options = [None] + ['Regular Option', 'Stat Check Option', 'Item Check Option', 'Quest Check Option']
    for x in ops:
        if x in ops:
            print(f'{x}: {ops[x]}')

The above acheives the same thing in a better way.
1. I'm not sure if recursion is the best way to have designed this problem. Perhaps you could have tried iteration first?

2. `self.search_word` is a rather long function. It also has quite a few repetitive pieces of code in the middle. Try to break up this function into multiple smaller functions, as well as see if you can refactor to have less duplication of code.

3. Perhaps you could include some tests to show that your code actually works as you say it does?
You should be able to work that out if you read my comment. I've given you pretty simple instructions that you should have no problem converting into code.
You could use two for + if loops?

The first for + if loop would be exactly the same as above but instead of printing the number, you'd append them to a list.

The second for + if loop would loop over the list, checking each element to see if it's the last element of the list. If it's not the last element, you print the element with a comma. If it is the last element, you print it with a full stop.
Either is fine - I think. I would recommend going back over it, but if you don't, it's likely that you will just pick it up along the way.
If you have a command line program, you pass it command line arguments in order to use the program.

For example, `cp` is a program in the Bash command line that copies a file. If I want to take a file called `music.txt` and copy it to create a new file called `music2.txt`, this is how I would use `cp` to acheive that.

    $ cp music.txt music2.txt

`music.txt` and `music2.txt` are the first and second command line arguments to the `cp` program, and represent the current filename and new filename respectively.
> Everyone would just switch to Unix and wine

If by this, you mean people using iPhones and iPads while drinking a glass of wine, you'd probably be correct.

If, however, you mean people using Linux desktop OSs whilst accessing Windows programs, then I think you are hugely overestimating both the awareness and popularity of the Linux desktop and/or WINE
With the iPhone, removing the headphone jack allowed Apple to put in a better taptic feedback system. Now, if you use wired headphones, this is a bad choice. But if you only use wireless headphones, then this is a good thing. Having the headphone jack isn't 100% great for every consumer out there. Hence, the original thought - "stop generalising people's use case for their cell phones".
Is it, though? I'm on the side of "stop generalising people's use cases for their cell phones", which means that we should have a range of devices that fit people's different use cases. Devices with removable batteries and without, devices with headphone jacks and without, devices of different storage sizes, and so forth. How is that less features and less choice?
Not everyone needs or wants all those features. People who use wireless headphones don't need a headphone jack. I personally don't want a removable battery because I prefer having a premium design instead, and so far no OEM has managed to bring the two together (LG tried and kinda failed). But apparently "stop generalising people's use cases for their cell phones" only applies if your use cases exactly match those of the /r/android hivemind.
The two blocks of code are not exactly equivalent to each other. Let's say `fileb` had a function named `bar`. You wouldn't be able to call `bar` at all in your first code block, but you could do `fileb.bar` in the second code block.
Yup - loop over the list, find where the element == obj, update a counter every time you have a match and then return the counter at the end. Child's play, but you should never implement that algorithm instead of doing `list.count(obj)`.
Agreed - a good interview must test the candidate on the work they'll actually do.
That is one way of looking at it. The other way is that, even if you are never going to write an algorithm that counts an object in a list or prints out the first 100 numbers of Fibonacci, these are easy problems for a software developer. You should be able to code a solution to these problems in your sleep. If you can't, then you don't have the required programming knowledge for a software development job - full stop. Such questions weed out a large number of candidates that simply can't code for shit.
It's always good to know how to invent a bicycle if you need to, but you should never do it if you can avoid it. As an example, an interview question might be "write an algorithm that gives me the count of an object in a list". If you can't write an algorithm to do that, you'll likely fail the interview. However, if you end up passing the interview and you need this functionality, you'd never write an algorithm to do that. You'd just call `list.count(obj)` instead.
General refactoring tips and tutorials can be found online.

Specific to your script, your top four functions are 95% identical to each other. This is a code smell - you are duplicating logic instead of reusing it. Look to create common functions that could replace those top four functions - either one common function or multiple smaller common functions.
I've think you've hit the nail on the head. I had the same issue when I was fresh out of uni. I was being rejected without interview for retail and restaurant jobs but when I found a job to do with software development in the financial sector, I was instantly successful. Unfortunately, it seems you may have to dumb down your CV somehow if you want to get the kinds of jobs.
Have you ever done any debugging? Now would be a good time to learn if not. Try to isolate where you are getting the None and figure out why, through debugging. Any good Python IDE will contain debugging, alternatively you can look into using the pdb module.

As an aside, there is a HUGE amount of repetition in your code. It could easily be 1/4 of the number of lines it is now. Once you get your code working, I'd highly recommend trying to refactor it.
No, they realised they were behind in mobile, and tried to shoehorn a mobile interface onto their desktop PC.

So what if I use most of my apps fullscreen? Not all app are good to be used fullscreen and not all apps need to be used fullscreen 100% of the time. Netflix fullscreen on my 22 inch monitor is OK. Calculator full screen looks obnoxious.
New Super Mario Bros U, Nintendo Land and ZombiU were the games I remember for launch. The former absolutely had the capability to sell big - you just have to look at how much the Wii version sold for to be able to see that.
You're pretty alone in that opinion there. Almost all the Mario and Zelda games released for the Wii U got high ratings from media and community alike.
I think the problem with the pad was that most people actually didn't want it to be integrated into their games. They wanted the GamePad for Off-TV Play, and the more you integrate the GamePad into a game, the harder that becomes to achieve.
Controller situation on Wii U was the true mess. You had Wii Remote, Wii Remote + Nunchuck, Wii Remote + Classic Controller, Wii U GamePad and Wii U Pro Controller all as different controller options. And it's not like you can buy one type of controller and have it play all your games. Many games accepted only one or two types of controllers.

With Switch, if you buy a pair of JoyCons, they are compatible with EVERY single game, no exceptions.
Here's your problem:

    def inputFunction(inPut):
        firstPlay = True

Anytime you call `inputFunction`, you are assigning `True` to `firstPlay`. This is regardless of how `inputFunction` is called. 

There are a number of other issues in your code as well - I see you using `return` in inputFunction but when you call `inputFunction`, you are not assigning it to a variable. This makes me think that you haven't quite understood what `return` does - I would research this to fully understand it because if you don't understand what `return` does then you will not understand how to write functions at all.

I also can't see where you make `gameLoop = False`. `if inPut == 'e':  return gameLoop == False` is not going to work. Partly because you haven't understood `return` (see above), mostly because you aren't assigning anything to `gameLoop`, you are just checking to see if it's `False` and then returning `True` or `False` based on that check.
In addition to what's been said, splitting code into smaller functions also makes it testable. In the professional world, any time you write code, you need to have a unit test to check that the code works as expected. Testing a larger function is harder than testing smaller functions, and if the function is too big it can become a downright headache to test properly. Having your code as more testable is always better design, even if you don't intend to actually test it.
Because it was introduced in 3.5, I would guess that it's a feature that is used more for personal coding than professional coding, since many professional installations of Python are likely to be older than 3.5.

I used type hints for the first time yesterday. It's a good feature, but for me it clutters the code and makes it harder to read. The code seems less Pythonic when I use it. But I've never properly coded in a static language before, so I guess that's why I have that experience. I can't understand why you wouldn't have that experience, having coded in static languages beforehand.
Why would it make it harder? Not having a programming job at all would hurt more.
It's because of what is actually being imported. The former imports the module into the current namespace; the latter imports the function directly into the current namespace. This is why you access the functions slightly differently.
For each number try `float(number.strip('-').rstrip('%'))`.
If you do `import fooddata`, then you have to call `eggs` as `fooddata.eggs(5)`. 

Alternatively, if you do `from fooddata import eggs`, then you can do `eggs(5)`.
A couple of things to ask 

* Are you calling `eggs` from a different file to where `eggs` is defined?
* If so, can you tell us what the filenames are and how you've done the import statements?
I fat-fingered my reply - check again, I edited it.
`data` is a dict of dicts (with a list thrown in there in the middle too). `'ln'` is a key in one of the bottom level dicts, not the top level dict. You are trying to access `'ln'` from the top level dict and failing. 

To access bottom-level lists and dicts, use extra square bracket notation. Try data['t']['pl'][0]['ln'] .
Anaconda absolutely has access to all of those. Perhaps you are using a different Python installation? Try launching Python from the Anaconda Prompt.
Python is complaining that the key `'ln'` is not in the `data` dictionary. If you inspect your JSON file, or if you print out the whole `data` table, you can see that this is the case.
Check `sys.stdout.encoding` on Python 3. Likely, that isn't UTF-8, for what reason.
Ah, I'm sorry, I can't help you there. In my current job, I rarely need to use the kind of data that Quandl and others provide.
I'm a financial Python developer. I would recommend it simply because it's convenient to have all the popular third-party package already installed for you. This is something that any Python developer can benefit from, not just financial devs. Numpy, pandas, openpyxl, requests, lxml, pytest and so on are great third-party packages and instantly accessible from a Anaconda installation.
Looking at where those places are (in Slough), I would very much doubt that you can use your Oyster that far. I wouldn't recommend bus - look to see if you can get a National Rail service in that direction first.
I'm the author of that theme - I'm glad you like it!
Mike Skinner would have fit very well with The Grand Tour if the producers hadn't tried to turn him into a ham-fisted American stereotype.
The comments on there are pretty funny. This one in particular I like a lot:

> Android after all is NOT an OS, it's a Java application running under Linux.

Such accurate knowledge on display. There can be no doubt this commenter is a top software engineer who knows exactly what they are talking about.
Which theme is this, out of interest?

This is a bug with Chrome. The issue has nothing to do with the background photo being streamed from the internet, because that is not how Chrome themes work. Chrome themes are downloaded to your PC fully before being executed. If you were to inspect the Chrome directory on your PC, you would be able to find the theme's source code and image assets.
I think it's disingenuous just to say that AMOLED > LCD like it's some undisputed truth. 

* LCD displays show more accurate colours than AMOLED. 
* LCD is far less prone to burn-in. 
* LCD panel-quality tends to be more consistent across OEMs - you can get really excellent AMOLED panels (Samsung Galaxy S panels) but you can get pretty poor panels as well (Pixel 2 XL). 


And so on and so forth. When you weigh up LCD vs AMOLED, I really think it comes down to personal preference. There's a reason Apple has stuck with LCD for almost a decade with their iPhones and are only just moving to AMOLED with iPhone X.
I don't think you will get many people agreeing with you that VS Code is better than Pycharm :) I use VS Code but only because my potato Intel Atom device simply chokes when I try to use Pycharm. Otherwise I'd use Pycharm all the time.
I had no prior coding experience whatsoever. Just go for it and see what happens.
I got a Python job from 3 afternoons of lessons + a 10 week summer project, half of which was spent coding. I never thought I would be good enough to get a Python job, but I was fortunately proven wrong.
I think the point is that Fuschia doesn't use Linux, that's why they are sad as a Linux fan.
Go for sales assistant jobs in the short term. As much as you dislike the job, it's what you have experience in and it's what you are most likely to get. Once you get one, you can then focus on getting a job in advertising.

Don't give up easily, but be realistic too. If you've only sent 50-60 emails, I'd suggest continuing. However, if you've spent a solid year applying to ad jobs and getting nowhere, it may be worth rethinking it as a career choice.

Whatever you choose, I wish you luck. I have personally been lucky in that I only had to spend two months once I graduated from uni to get a job. But those two months were the worst months of my life and I had just a small taste of how depressing job hunting can be. I hope you find something soon.
Usually I'm good with phones, though admittedly I don't own an iPhone. The incorrect error message totally threw me off. If the error message had mentioned iCloud in some way, or if there were answers in Google, I'd have probably gotten it.
The OS is barebones right now. It's years away from release. I wouldn't take the current UI as an indication of what will actually ship. 
I highly doubt that. The Play Store is what sets Android apart from other, lesser mobile OSs. Third party support is SO hard to get if you don't already have it, and if Google were to abandon the Play Store, Fuchsia would effectively be starting from scratch with regards to third party support.
Disagree. If Google played hardball, it would make an impact in phones pretty easily. All Google would have to do is have the Play Store on Fuchsia OS and then prevent OEMs from releasing Android on new devices by denying them Google Mobile Services. Google already does the latter with regards to older versions of Android. 
Legends contains a number of Origins levels. As far as I can telling having played every level in Legends, I found Legends levels to be much better than the Origins levels as a whole.
Author - Jason Ward. Why am I not surprised?
I think it only works for devices with SIM cards now. I think it was also meant to be used with other messaging services that could integrate into it, but no-one decided to do that.
Right, because almost tricking Lily into letting him touch her breasts, or cheating on Nora with Robin, or setting up an elaborate con to manipulate Robin into being engaged with him, were selfless acts, were they?
Disagree with a lot of what you say.

Barney doesn't get better throughout the series. A lot of stuff I mention above occurs during the second half of the show. Plus, when his marriage to Robin breaks down, he reverts back to the same behaviour of lying and manipulating women to sleep with him again.

Barney is not the second nicest person and Ted is not worse than Barney. Ted has his own issues, granted. But Ted never lied or manipulated women into sleeping with him like Barney did. Ted never tried to manipulate Lily into letting him touch her boobs. Ted never tricked any of the women he engaged like Barney did to Robin. I can't understand at all how you can think Ted is worse than Barney or Barney is the second nicest person given the amount of shit Barney has done.
Is that for all buses? I heard that on Friday and I thought it was kinda silly. Especially given that you hear it most often when the bus has already set off, which kinda negates the entire purpose.
This code here:

    entered = input("enter: ")
    entered_set = {i for i in entered}

    if (entered not in words_str and
        entered.title() not in words_str and
			  entered.upper() not in words_str and
			  entered.lower() not in words_str and
			  entered.capitalize() not in words_str):

Try to avoid guessing every single way that a user might input text into your script. Instead, modify the user's input immediately so you know exactly what you are getting. This then let's you greatly simplify your logic.

    entered = input("enter: ").lower()
    entered_set = {i for i in entered}

    if entered not in words_str:
I should have put the word "twist" in quotes. I definitely think the writers intended it to be a twist. My problem is that it was easily-guessed. /r/HIMYM is filled with redditors questioning if the mother was dead, many many years before the finale aired. It was in the back of my mind throughout the finale, which is why I was disappointed because I wanted something novel, not something that people had saw coming a mile away.

I agree that the only the last season is a waste by the undoing of Barney and Robin's wedding, not the whole show. Though I would argue that, if an episode undoes an entire season, then that's definitely a problem with that episode, not just the season itself :)
The biggest suggestion I would give you is to use functions.

At the moment, your code isn't very modular. Everything is in one big lump. This is a problem for a few reasons:

* It makes your code harder to read for others. Reviewers have to read the entire script all at once to make sense of what's happening.
* It makes it harder for you to reuse your code in multiple places. You're more likely to end up repeating yourself rather than reusing logic you've already written.
* It makes it impossible to test your code. As you progress in programming, you'll hear about unit tests - writing tests for your code so that you can prove that your code works. Testing a huge lump of code in one go is very tricky.

Breaking your code into multiple functions will help fix many of the issues you see above.
I don't like the ending because 

* the mother dying was such a shitty twist. 
* while Barney and Robin are a terrible couple, the show did spend an entire series on their wedding. To kill their marriage in the beginning of the last episode just makes the entire series feel like a humongous waste to me.

I think you are right about Ted though. I would add that I think Barney gets shielded from a lot of criticism because many guys aspire to be like him. They see the looks, the girls and the money and they see him as awesome when in fact his character is a total asshole.
He's up front about what he wants? Barney wrote an entire book on how to mislead and trick women into getting him to sleep with them. He designed an elaborate con to manipulate Robin into getting engaged with him. He's the least up-front person of the crew.
But it does though. Throughout the show, the message is that he's always cared for his friends. It's a message reinforced in the last series in the episode where flashbacks show how he would give his friends a drink to cure their hangovers. Except the message is BS - he's done many shitty to his friends.
In the later seasons he's still a terrible person. He sets up a multi-month long backstory just so he can touch Lily's boobs.  He killed his first engagement to Quinn because he wrote a childish, ridiculous pre-nup. He brought about his second engagement to Robin by manipulating her into thinking he was going to marry Patrice instead. And when his marriage to Robin breaks down, he goes straight back to his sleazy ways for years.
To be fair to Skyler, Walt would leave the house for hours, sometimes days at a time, without telling her where he went. That part *is* his fault and Skyler's reactions are totally reasonable.
Being manipulative to Jesse and his own friends is bad, but barely the worst of it. The guy was a drug-dealing serial murderer who thought nothing of killing/ordering the killing of anyone, innocent or guilty, if it benefited him.
The guy is a great character but the worst person. Treats so many women like shit, including his own female "friends" at multiple points.
Barney Stinson is a great character but a terrible person. 

His treatment of women is despicable. He lies constantly just to seduce women. He tells women anything if it will get him sex with them, only to ditch then after said sex. The way he ditches women is brutal, once when camping in the woods with a girl, he stole her vehicle leaving her alone in the woods just so he could ditch her.

He treats his friends crappy too. The show pretends like, even though he treats women like crap, he always cares about his friends. But it's crap. He's was willing to set up an elaborate backstory just so he could trick his "friend" into letting him touch her breasts. He cheated on his girlfriend. His first engagement broke down because he gave her a pre-nup with ridiculous rules to follow, many sexist . And his second engagement occurred because he set up another elaborate con where he tricked the girl into thinking that he was going to marry the person she hated the most instead.

In short, Barney is a major douche. The worst of the 5.
Each menu item *is* slightly larger. The menu itself is much larger, but that's because there are a number of items there so it adds up.

Not liking the dark theme because you don't like the colour is just a preference. If you prefer lighter colours, that's fine, but lots of people prefer darker ones. Most of the desktop apps I have installed (Spotify, Chrome, Microsoft Office, VS Code, PyCharm, etc) have full dark themes available. You might see it as unnecessary because you prefer lighter themes. That's fine, but clearly lots of people have been asking for dark themes otherwise so many popular desktop apps wouldn't include them.
I live in the UK where we don't have all cubicles too. I don't get how just going to the cubicle (assuming it's free) and using one square of toilet paper is in any way significantly longer than using a urinal.
That requires having to button up and then button down again when you transfer from urinal to cubicle. That's *more* effort than just going straight to the cubicle.
It barely takes any time at all...? Literally one square is enough and it takes all of 5 seconds to do. The only time lost is if the cubicles are taken and you have to wait for them to be vacated.
In my opinion, the colour should match the colour of the taskbar. It only does that if you stick to the default, which is definitely something that could be improved. 

As for your other comments, the context menus are not designed for tablets - touch users get a much bigger context menu when they use the taskbar. The size of the context menus are slightly bigger than the desktop context menus, but not obnoxiously so like the overflow menu in Microsoft Edge. I'm OK with their size. There are places in Windows 10 where the UI designers have made too much concessions to touch users, but I don't think the taskbar context menus are one such place.
Zero drops is to go to the cubicle and use toilet paper to dry yourself instead.
Why should it be white? The taskbar is dark so the context menu should be dark too. They should make a proper light taskbar + context menu for the light theme, but that's a separate issue IMO.
I think that's a Linux thing. Maybe Mac as well (idk) but certainly not Windows.
Conversely, the "valleys" make it much easier for you to grab the window titlebar when it's in fullscreen mode. Filling the whole of the titlebar with tabs means trying to move the titlebar is far harder.
One small thing to mention.

Everyone here is saying that a decorator is a function that takes in a function and returns another function.

This isn't 100% correct - technically a decorator is a callable that takes in a callable and returns another callable.

Why the distinction? Because functions aren't the only type of callable. Class objects and instance objects can also act as decorators as well, if the object implements `__call__` to become a callable object.
I only really know Python, so I'm biased to say learn Python! :) It's not as verbose as other languages, so you end up writing less code overall. And because it's a very high level language, a lot of complexity is abstracted and hidden away from you, which means you should make faster progress towards writing functional programs when you start learning it.
What are you waiting for? No time like the present! :P
Python is strict with indenting because it has to be. Indentation isn't merely "style" in Python, it's functional in that it denotes a new code block. This is why Python has to be strict with it, i.e. preventing mixtures of tabs and spaces for indentation.
Ok, let's discuss these:

Expensive peripherals - this is true enough, the dock in particular is extortionately high for what it is.

Controls are too small - the Switch is basically a portable device and so needs a low-profile form factor. You can't make it much bigger without severely compromising that. Switch is actually pretty large for being a portable device. If you need bigger controls, get a Pro Controller.

Storage space too small - fair enough but microSD card expansion makes this not too big of a deal for me

Charging connector position - it has to be at the bottom to work with the dock.

Games without Nintendo art direction - we'll have to see what third-party support will be like in the next year to see how this one goes.

Lack of Netflix - Switch should definitely get Netflix and it's disappointing it doesn't have that when Wii U did. I'm 100% certain the issue is with Nintendo rather than Netflix.

Battery life - I get 4 hours+. For a single day battery life, I think that's fine. I don't play more than that much per day in handheld mode. If you want more life then get a battery pack.
I know 7 people who own a Switch. However they are all co-workers and software developers, which probably is a mitigating factor :3
You are looking a mid-ranger and trying to compare it to your S7. That's not really fair. Nokia has a flagship out - the Nokia 8. It has SD 835 SoC, 1440p display, Oreo released for 95%+ devices at this point, and it costs £400 off contract, which is far cheaper than the likes of many flagship devices.
Wait for the next Nokia 8 next year then.
I think it will be launcher3, that's what I have on my Nokia 8.
This used to confuse me with older versions of Android, where the nav buttons in landscape mode would always appear on the right even if the right was the top of the phone. 

However, now that the nav buttons always appear towards the bottom, whether that's on the left or the right, this no longer confuses me at all.
You do have an option to turn it off - you change the launcher.

In order to give what you want, Google would have to provide a new settings options any time they release a new feature. Google aren't going to do that, because they aren't interested in delivering an ultra-customisable launcher themselves. They are interested in developing a good but non-complex launcher.
720p 30fps in handheld mode for a fullly-featured triple A game. Please explain to me how you can play games like Zelda Breath of the Wild and Skyrim on your mobile phone at those specs with the same experience.
The Wii sold a ton of consoles and yet missed out on a lot of games that were PS3/Xbox 360 only.
Nintendo DS and 3DS had this feature as well. It's great but it's common to many modern handhelds.
I have a wishlist for HMD in general, not so much with their phones.

Simply, I wish for Nokia to be more honest with their update rollouts.

Nokia has to make it clear that their upgrade rollouts occur over a period of months, and not the ”2 days, maybe a week" that they claimed with respect to Oreo on the Nokia 8. I received my upgrade a full 5 weeks after the "2 day" announcement, and some people are still waiting on their Nokia 8 to receive the Oreo upgrade.

Nokia also must stop publicly ignoring everyone who asks about where their update is. In the last 5 weeks, any attempt to tweet Nokia Mobile clarifying the situation has been met with silence. Anyone bringing this issue up on the Nokia forums has met with a similar fate. If Nokia had come out with a clarifying tweet that said "actually, we are rolling out Oreo over two months", I wouldn't have minded that. Their lack of any public statement simply to save face has been really disappointing to see, and I hope that Nokia can change this behaviour in the new year.
The easy, obvious way is to make a fake account and post as the opposite gender. Of course, that brings up other issues, but it's definitely easy and obvious.
Let's not go Nexus-circlejerk here. My Nexus 6P bit the dust in less than two years because the battery life fell off a cliff. Lots of Nexus 6Ps are having battery and bootloops issues, lots of Nexus 5Xs are having bootloop issues, etc etc. Thankfully I got a full refund from Google, but if I had been outside my warranty period I'd have been totally screwed.
[It's a million times better than the Recycle Bin in the original Windows 10 Technical Preview.](https://winaero.com/blog/wp-content/uploads/2015/04/old-recycle-bin-win-10.png)
If you are still in warranty, I'd recommend an RMA.
Yeah, that strategy doesn't work. I think the only one that works is removing SIM, clearing the data of Carrier Services app, and then using NordVPN to connect to Finland. That seems to be the option that works the most.

However, I would just recommend to stay put and continue waiting. Yeah, it's really frustrating, especially the way Nokia is handling this publicly, but clearly they are still rolling out Oreo, so I would just wait.
I just got Oreo yesterday, after waiting 5 weeks. So hang on in there! :)
The problem still exists - many restaurants have the Heinz glass bottles instead of the plastic ones. The key is to realise that ketchup is a non Newtonian fluid - when resting it acts like a solid but when you shake it it acts like a liquid. Shaking the bottle upside down vigorously and then quickly uncapping it will cause some of it to be released. Repeat a few times and eventually you'll get enough of it out.
The new Nokia Android phones are really good. I have a Nokia 8 and it's an excellent device. The only thing I'm *slightly* salty about is how they rolled out Android 8.0 Oreo (they said they would take two days to roll it out, they ended up taking 5 weeks for me). But other than that I have no complaints.
Vodafone
Yup.
The GamePad's top bezels do nothing to make it nicer to hold. In fact, because they make the device taller then it needs to be, for me it's a stretch to hit L and R buttons. 

The N64 controller shouldn't be criticised for looking dorky because there was a reason why it was designed like that at the time. But then you have other dorky products like the GameCube console and the original fat DS which look dorky for no appreciable reason. At least with the latter, Nintendo redesigned it with the DS Lite and made it look orders of magnitude better.
Compared to smartphones, Switch has huge bezels. Compared to the Wii U GamePad, its bezels are tiny. The GamePad's side bezels are huge but understandable as they make the device easier to hold. But the top and bottom bezels for the Wii U GamePad are huge while adding nothing to the aesthetics of the device.
The design of both things were done with regards to practicality. You say that the Switch is unusable as a handheld, but if the Wii U GamePad was portable then it would be even less usable as a handheld as it would be far too big and bulky. Plus, I think that the Switch definitely *looks* better due to its lack of bezel.
This is to be expected though. The Wii U GamePad was not expected to be used portably, hence they could optimise the form factor for the indoors. This means having the grips underneath the body and having full-sized buttons and triggers. Switch console was designed to be used anywhere, so they had to go for a slim design and smaller buttons and triggers. If Switch console had been designed like the Wii U GamePad, it would be less easy to carry around.
I finally got Oreo yesterday, 5 weeks after the announcement of the rollout. So don't give up hope!
If your number is prime, then your code just has a bare return statement. You should know that in Python, if you don't explicitly return something, then your program will return `None`. This is what is happening in the case where your number is prime.
Have a look at either Greenshot or ShareX.
The Switch's OS really is good. It surprised me how good it was, because I owned a Wii U and the OS was one of the worst things about it, for me.
Methods that shouldn't be accessed should be prefixed with a single underscore to indicate that they aren't part of the public API and shouldn't be accessed. But if a user really wants to access that method, why should they be stopped? I don't get why it's a big deal that this method can be accessed, really.
See, I never looked at any trailers except for the initial reveal in 2014, which showed off only the art style and the Ancient Guardians. I refused to look at any other trailers for the game until I beat the game thoroughly. I finally beat the game a few weeks ago and the very first thing I did was watch the 2016 and 2017 trailers. Unquestionably, I'm so very happy I did that. I wouldn't have enjoyed the game to the level that I did had I watched those trailers.
If you have separate reasons why you are unhappy whilst single (say, you are suffering from depression), then sure. But what if you are unhappy *because* you aren't in a relationship? Why would being in a relationship not fix that?
https://youtu.be/dqAo4D7bfnQ?t=53m17s

https://youtu.be/dqAo4D7bfnQ?t=1h30s

Watch each link for about a minute.
It was pulled for Surface RT, really. Surface RT was so weak it couldn't play Cut the Rope without suffering really low framerate drops.
Somewhere in the middle. I did Biochemistry, but my last module + final year project was Bioinformatics-based, with significant elements of Python programming.
I definitely agree that it matters. There's two aspects here - the networks that the university gives you, but also the name of the university itself. I went to a fairly top-tier uni. Whilst I pretty much made zero use of their networks, I'm certain that just being able to say that I graduated from that university gave me a significant boost all on its own. 

With that said, I don't believe that it's mandatory. What's mandatory is having some sort of degree. Without a degree, there are many, many career prospects that you are completely locked out of
Not necessarily. Don't get me wrong, a networking system helps a *lot*, but it is possible to get a good job without it. I got my current programming job without any networking at all. However, a college degree is actually mandatory. I'm certain that without my degree, my current employers would have dumped my resumé in the trash without a single thought.
You're definitely exaggerating on the Shrines point. Taking your point literally is claiming that 40 shrines out of 120 were Test of Strengths. I do not remember it being anywhere near that high of a number. I think it's actually only about 20 or so. All the other shrines are fairly unique IMO.
I'm surprised people cared about that. For me, it really wasn't long before I got to the point where I had far more weapons than I knew what to do with. My weapons do not break fast enough to equal out the number of new good weapons I was coming across.
Virtually every modern 3D Zelda has been 30 FPS. Obviously it's not ideal but it doesn't spoil the gameplay at all for me.
They are still making modern versions of 2D Mario. New Super Mario Bros 2 and U were released just 5 years ago, and Mario Maker only a few years ago. And of course there is Super Mario Run as well. 2D Mario is far from dead.
I guess you were downvoted because people just read the first line and automatically assumed you disagreed with the punishment. 

I agree with you in that the punishment isn't "life-ruining". That's a different thing from saying that they didn't deserve that punishment. I think the punishment is very fair, and actually I wouldn't have minded seeing them get a custodial sentence for what they did. But the actual punishment itself isn't "life-ruining", just "life-altering".

However, I disagree with "don't ruin someone's life over a college prank". Some really really shitty things, up to and including serious sexual assault and rape, have been done and justified/thought of as "just a prank". I am well in favour of ruining the lives of anyone who does that kind of shit.
Why not try to run the code, see what error you get, and try to go from there?
In 3.6, this was an implementation detail in Python that wasn't guaranteed and that people should not have relied upon, in case future dict implementations broke this.

However, only 5 days ago, [it's been confirmed that it will actually be a guaranteed part of the language](https://twitter.com/raymondh/status/941709626545864704?s=17), which is great to hear :)
Themes only specify the colour of the buttons, not the actual buttons themselves. Chrome has fixed the issue, it's a flag you have to enable on chrome://flags called Custom-drawn Windows 10 titlebar.
To be fair, it's very difficult to prepare people for jobs when there are so many different jobs out there. Degrees can't give everyone the depth that they need for their first job. What they can and should do is get you to be good at self learning so that it doesn't matter.
It's weird that people can do CS degrees, even Master's in CS, and not know how to program properly. What have you been doing for those 3-5 years if, when you leave, you can't program?
I know you are joking with this comment post, but some people actually want this to happen and it baffles the hell out of me as to why they want it. 

The initial switch would be hugely disorientating for everyone who didn't live at or near the prime meridian line. 

But, assuming everyone got used to it, it would simply swap one set of problems for another. You still need to know how many hours someone is ahead of you if you want to contact them. Someone in Britain wanting to contact someone in California will have to think "ok, California working hours are 5pm to 1am, so I can't contact them until the end of the day". You still have to have an unofficial system of time zones to do this, so you end up solving very little.
You need to import the time module. Put at the top of your script:

`import time`
When you start writing scripts that are more complex, you'll want to break it up into functions. 

Now, you won't need to have specific functions for one liners like addition - in fact, Python actually has functions for addition, subtraction, etc. in its standard library. 

But let's say you are writing a script to take a CSV file from FTP server, convert to Excel and save the new file to FTP. The functions you might have are : connecting to an FTP server, opening/closing a file from an FTP location, reading from/writing to a file, etc. You'll want to use functions here because, it's easy to inspect code that's broken up that way instead of in one huge code block, and because you can reuse code. For example, you may have one FTP server for the incoming file and outgoing file, but you can reuse the FTP connection function for connecting to both servers.
Support app just tells me "more time is needed to release the Oreo update" but there's literally no indication as to how long. However, you only get this information in private chat. I hate that, publicly, they aren't admitting that they are still rolling it out. They want to give off the public impression that all the Nokia 8 devices have it, which is BS.
Well, I still don't :( And I don't want to have to jump through hoops to get it. I'm ok waiting but I wish Nokia weren't so silent on this issue. They're acting like everybody on Nokia 8 has the update when this is not the case.
On the flip side of what /u/MrFluckDuck mentioned, it has been 3 weeks since Oreo was released for Nokia 8. However, I haven't received it yet on my UK SIM Free Nokia 8. I also don't have Dec monthly security update either. Talking to Nokia support is useless, they can't provide you with any timeline as to when it will arrive. Tweeting Nokia or replying to their forums yields radio silence. Be prepared to have to remove your SIM, clear the cache on the Google Services Framework and then connect to a VPN if you want updates.
His 6P videos were conclusive proof that Nexus fanboys could be just as bad as Apple fanboys. He dared to say bad things about what seemed to be one of the best Nexus devices of all time, and got so much unwanted hate for it. Lots of people on the comments were saying how stupid he was to bend his phone and what did he expect if he was to bend his phone like that and so on. You just know those same people would shit all over an iPhone if it did the same thing.

His video showed what we all eventually started finding out in the months and years ahead. The Nexus 6P's hardware is a joke. It looks like a well-built phone from the outside with its metal and glass construction. But beauty is skin deep. People have had issues with metal kinking around power button, hardware-induced bootloops, and now everyone is facing battery issues because either the 810 eats batteries with its overheating or Huawei put the worst battery into the 6P (probably a little of both). It's terrible, really.
I disagree. I think if-else is better if you only have three elses. But if you end up having 30 else statements, then using the dictionary solution is far better. Using the if-else construct would look like a huge mess.
Ok, since you aren't even responding to anything in my comments anymore, we're done here.
Below are four separate sources, one of them Microsoft themselves, backing up what I say. Either everyone in the tech world except you suffer collective amnesia with regards to this, or maybe, just maybe, you are the one who's wrong here.

---

https://www.laptopmag.com/articles/snap-windows-10

> PC users have been able to snap programs to the left or right side of their screens since Windows 7 launched in 2009. However, with Windows 10,  Microsoft has taken snapping to the next level, adding the ability to split your screen in quarters...

https://www.techrepublic.com/article/snap-a-truly-slick-feature-in-windows-10/

> When it was introduced in Windows 7, Snap showed potential as a windows management technique. ... With Windows 10, Snap has really become a truly slick feature. You can now snap windows to the four corners and the two windows in a split-screen formation. 

https://www.howtogeek.com/198230/how-to-use-snap-assist-and-2x2-snap-on-windows-10/

> The extremely useful Snap feature — introduced as “Aero Snap” in Windows 7 — is much-improved in Windows 10. Snap Assist, 2×2 snapping, and vertical snap features help make you more productive on the desktop.

https://blogs.windows.com/windowsexperience/2015/06/04/arrange-your-windows-in-a-snap/

> Corner Snap. When Windows 7 was released in 2009, 4K technology was in its infancy and splitting the screen in half satisfied most use cases, even with external monitors. ... For Windows 10, we explored a number of interaction models for creating more advanced window layouts. Ultimately, we built upon the success of snapping to edges by extending the gesture to work with corners.
I have used Windows 7. I use it every day at work. It can only snap 50:50. You cannot snap in all four corners. Windows 10 lets you drag a window to the corner of your screen and it will take up 25% of your screen in that corner. To achieve the same in Windows 10, you either have to manually resize the windows to get that effect, or install third-party software.
> Everything you've listed minus night mode is in Windows 7

That's simply not true. Everything I've listed is only in Windows 10. Windows 7 does not have those features.
It's pretty easy to have this in a dictionary, I think it just requires more thought:

    from collections import OrderedDict

    A = 11.1

    mapping = OrderedDict([
        (10, 'a',),
        (11, 'b',),
        (12, 'c',),
    ])

    for x in mapping:
        if A < x:
            print(mapping(x))
            break
I just knew that someone would post an EEE comment. Literally any time Microsoft does anything with open-source, there's someone to post the wiki link to EEE, even when there's no relevance to EEE whatsoever.

To quote the article you posted yourself:

> "Embrace, extend, and extinguish" ... was used internally by Microsoft to describe its strategy for entering product categories involving widely used standards, extending those standards with proprietary capabilities, and then using those differences to disadvantage its competitors.

Literally none of this is happening here. Microsoft isn't trying to enter the same product category with this move - Excel and Python are very distinct products. Microsoft also has no way of disadvantaging Python with this move either - how exactly would that play out? What exactly could Microsoft do that would substantially hurt Python here?
With non-hashables, I guess the options are to make the object hashable or use a different container (either for the object itself or to replace the dictionary).

I'm confused what you mean by conditionals though? I thought if...elif statements *were* conditionals, so perhaps you could explain for me?
Why do you want to see switch/case? If you think that your if...elif block is too large that you need switch/case, I think you are looking at the problem wrong. For example, if you have code that looks like this:

    if x == 4:
        a()
    elif x == 5:
        b()
    elif x == 6:
        c()
    elif x == 7:
        d()
    elif x == 8:
        e()

you should not think about changing this into switch/case, you should think about what the relationship between the condition and the outcome statement is, and see if you can abstract this away into a list or dictionary, such as the below:

    mapping = {
        4: a,
        5: b,
        6: c,
        7: d,
        8: e,
    }

    mapping[x]()

This is far better than using switch/case when you start to get into large number of conditions.
> Microsoft is such a joke that there's not one single part of Windows 10 that is an improvement on Windows 7. 

I disagree. I use Windows 7 at work and there are many features that I miss. Snap assist, snapping windows to all four corners of the screen, virtual desktops, Ctrl+C and Ctrl+V on CMD, improved Snipping Tool, Up button on Windows Explorer, vastly better Task Manager, built-in night mode, activating windows on mouse hover, and countless other features. 

There's a lot I don't like with Windows 10, but to say it doesn't have a single thing better than Windows 7 is clearly silly.
This is not what "Windows as a service" means. All WAAS means is that Microsoft is no longer delivering large Windows upgrades every 3 years, but instead having one OS which they continuously update by provide feature updates twice a year.

Having ads in products is a completely separate thing to WAAS. In fact, Minesweeper and Solitaire have had ads since Windows 8.0 back in 2012, which proves that the two things are separate.
Sure, that's the way you would usually do it. I just wanted to focus on OP's main question, I guess, I didn't look too closely at the rest of the code.
Makes sense. Try to avoid globals as much as you can from now on. Just pass values into your function and then return a value at the end. Beginners have no need to use the `global` keyword at all.
Look into `xlrd` or `openpyxl` to see how you could persist the data into an Excel spreadsheet. Imo, it might just be easier to use the `csv` module to persist it to a CSV file. 

The big issue is that you aren't using functions in your code - it's just one lump of code. Try see if you can rewrite this using functions. This would help make your code more modular.
Remove the globals and have the function return those values. A good idea is to do it within a tuple:

    def newColors():
        testTime()
        if dayTime == False:
            imgRed = randint(20,50)
            imgGreen = randint(20,50)
            imgBlue = randint(20,50)
        elif dayTime == True:
            imgRed = randint(100,255)
            imgGreen = randint(100,255)
            imgBlue = randint(100,255)
        return (imgRed, imgGreen, imgBlue)

Then you call the function to retrieve your tuple:

    colour_tuple = newColors()    

Or combine this with tuple unpacking to get the three individual values out instantly:

    colour_red, colour_green, colour_blue = newColors()
Is OP *that* new to Python? I look at their code and I see someone who can write clean code (albeit simple code), and who knows how to use dictionaries, classes, composition and other things correctly. I think they could grasp something like pytest (at least the core elements of pytest) easily enough. And once you learn that stuff, it makes your code far more robust.
Your code looks pretty fine, IMO. I have a few nit picks. 

---

You don't need brackets in an if statement. The brackets in `if(name not in self.cashflows)` are redundant and `if name not in self.cashflows` works identically to the above.

---

Your tests.py do not actually contain good tests. They show how your classes are to be used, which is good. But all they do is print out what the instance attributes are. They don't check that your instance attributes are what you expect them to be. 

I would highly advise looking into using a test framework (such as unittest or pytest - I would recommend the latter) in order to write some proper unit tests. 

A good first step would be to use a test framework to check that your instance variables are the values you expect them to be. Once you do that, you could expand the test to make it more meaningful by testing that your instance methods return the values you expect them to return.
Break it down and think about how you will approach each one.

* You'll need to know the length of your string.
* You'll need to inspect your string to find out how many vowels are in it. You could iterate over it, checking if the letter is a vowel, and keep a count somewhere of how many vowels there are.
* Finally, with those two values you will have to do a final calculation to work out the percentage.
While what you said is true, please do not encourage people to use the `*` syntax! The syntax that should be encouraged is `from math import sin`.
There's no such thing as "exiting a module". Once you import a function from one module into another, you call the function and that's that. If you need the imported function to return a value to your main script, then you use the `return` keyword in the function, but that's all there is to it, really.
[Chrome is adding adblocking capabilities natively.](https://blog.google/topics/journalism-news/building-better-web-everyone/) But I doubt it'll make everybody happy. It'll block intrusive ads but ask for a fee to block all ads on participating websites. Most people don't want any ads at all so will continue to use solutions that adblock everything.
[Chrome is adding adblocking capabilities natively.](https://blog.google/topics/journalism-news/building-better-web-everyone/) But I doubt it'll make everybody happy. It'll block intrusive ads but ask for a fee to block all ads on participating websites. Most people don't want any ads at all so will continue to use solutions that adblock everything.
At these lines here is the issue:

    max((high[i]-low[i]),(high[i]-close[i-1]),(low[i]-close[i-1]))
    max_bar.append(max)

You are calculating your max, but then you aren't assigning the value to a reference. So you are unable to append the max value to your list. What you are actually appending is the *function* max rather than what the max function returns. Better to do this:

    max_value = max((high[i]-low[i]),(high[i]-close[i-1]),(low[i]-close[i-1]))
    max_bar.append(max_value)
Well, the way you should do it is by having the code that raises the `SystemExit` in its own function that only gets called when you want to run the module directly, and not when you want to import the module. The idiom we use for this is `if __name__ == '__main__'`. This is because, when you import a module, `__name__` is equal to the module path, but when you run a module directly, it's equal to `'__main__'`.

    def main ():
        # do stuff
        if something:
            raise SystemExit
        # do other stuff

    if __name__ == '__main__':
        main()
When you do the first instantiation of `MailFile`, the `__init__` gets called on `MyStreamListener`. Here, you are creating the instance variable `self.time`, not `self.start_time`. That's why when you later try to use `self.start_time`, it doesn't work.

This code seems to me that you are trying to shoehorn inheritance into somewhere where it's not needed. Be wary of using inheritance, and in particular be VERY wary of using multiple inheritance like you have done in `MailFile`. Many languages don't support it, and often for good reasons, because it can make things very complex. I'm not sure that you really need inheritance here.
How many loops are you doing, exactly? If you are only doing tens of loops or less, then you should prioritise code readability over performance as the performance benefits of going with one approach over another is likely going to be minimal.
Having it under the screen means there's a wider range to aim for, compared to having a back fingerprint scanner. It also means you can unlock the phone on a table as well.
The only reason that's the case is because it was designed to run at 720p 30 FPS on Wii U, which is a potato compared to most PCs with decent specs.
That's really great to hear. Playing Okami Wii and having the game simply end on a static picture having just beaten the final boss was super jarring.
So, I think there is some nuggets of truth in what is said here. 

It's true that if you use an IDE that always shows you errors automatically and always autocompletes boilerplate for you, you'll struggle when the IDE is taken away. Suddenly, when you are in an interview and you are given pen and paper to write code down on, you don't have all of that and you'll struggle as a result. My technical interviewer for my current job has interviewed probably hundreds of CS grads at this point, including some that had masters in CS but couldn't code for shit in their interview. He hypothesises that the IDE is the reason why.

It's also true that learning the fundamentals first before learning the newer features is the way to go. It's often said learning a language that's lower level than Python can help you be better at Python. That said, sticking only to Python 2 is silly in my opinion - once you learn the basics you need to learn the newer features so you know the up to date way of doing things.
Well, I'm on Vodafone, guess that's the issue! I bought an unlocked phone to get away from this kind of stuff though
Yup, it's super annoying e_e
More usage of Bing -> extra ad revenue.

I heard somewhere that something like 40% of Bing traffic is Windows 10, which if so means it's working.
The key with those is to use `dir(object)`. This will give you a list of methods and attributes that the object has. You can use this information to call those methods or retrieve those attributes from the object in question. In this way, you can query the object to learn more about it.
If you use module code, you should be able to explain what that code does, at a high level, and why you are using it. What you shouldn't need to understand is the implementation details of the module code.
The idea that you shouldn't use modules to do stuff is asinine. Why waste your time reinventing the wheel? When I code, I don't bother with writing an algorithm to give me the log of a number, or with creating a dictionary structure where the key-value pairs are ordered, or with creating from scratch a way to read XML files. I use modules to do that work for me, because why not? 

The only reason not to is if you are coding as a hobby and you want to know yourself how to implement these things from scratch. But if you are coding for a degree or in a job, you are wasting your time not using modules.
I disagree, I think Google's decision to shut down Nexus in favour of Pixel was independent of the 808/810 chips.
The Nexus 6P community would beg to disagree :)
Your code looks fine, you've called all the main instance methods within the `main()` function, I'm not sure what you need help with exactly.

As an aside, the first 6 getters and setters in your class are completely pointless. Python is not C++ or Java. We don't need getters and setters for our code because we have a feature called properties which allows us to control access to our instance attributes only when we need it. Hence, you should remove those first 6 getters and setters from your code.
Snapchat is bad on Android, full stop. Snapchat are literally rebuilding it from the ground up because they didn't build it correctly the first time and they can't incrementally improve the app to be on par with the iPhone app.
A lot of times you are forced to deal with inheritance in codebases, so it's definitely important to know how it works. The implementation details of the work I do - a lot of it is inheritance.
Not really. Properties are to be used when you need to control how an attribute is accessed. Imagine the instance attribute `self.x` that takes an int. If you always wanted to make sure that `self.x` returns an int rounded to the nearest 10, or you always wanted to make sure that, if someone tried to set `self.x` to a string than an exception would be raised, this is the kind of thing you would use properties for.
I'm literally saying the exact opposite :)
Nothing wrong. That's my point - you should not use instance attributes for variables used in one method only. You should stick to local variables.
Firstly, as mentioned, you need to access `Hold1` and not `Hold`.

Secondly, [if you don't pass a `fieldnames` argument to `DictReader`, it automatically uses the first row as headers.](https://docs.python.org/3/library/csv.html#csv.DictReader) Hence you need to watch that the first row of your csv file doesn't get consumed immediately.
My main issue is that in certain places you seem not to see the difference between normal variables (e.g. `x`) and instance attributes (`e.g. self.x`) . There are numerous instance attributes that you create and then use nowhere else in the class. 

Think carefully when creating a new instance attribute outside of `__init__()`. This is allowed, but it is not common behaviour. Certainly, if you create a new instance attribute outside of `__init__()` and you don't use it in any other method, that's almost certainly the wrong choice. And if you are creating several instance attributes outside of `__init__()`, that may be a smell that you are using too many instance attributes.

When you do create an instance attribute outside of `__init__()`, you should still write `self.x = None` in your `__init__()` method, so that readers of your code can see all your instance variables in one place. 


Fine, but then the argument is used Pixel XL vs brand new Nokia 8. Nokia 8 will have more storage, better SOC as normal, but because it's a new device it'll also have longer warranty, better battery life and no physical defects. Pixel XL has better camera and more immediate updates, but that's pretty much it.
The `xy` variable is local to the `self.action()` function. You can't access it outside of the function, unless you use instance variables (e.g. `self.xy`) or unless you return `xy` from `self.action()`.

Out of curiosity, why are you trying to avoid using `self`? Without instance variables, it's very difficult to get any of the value of using a class.
Add it as an Exchange email account. Then it will show up in Google Calendar.
Going off Google Store, Pixel XL starts at over £700 off contract, and just for 32 GB. If you want more storage, you have to add another £100. But all that's moot because it's out of stock anyway.

Instead, I went to buy a Nokia 8. It's £400, almost half the price. And it comes with 64 GB + microSD expansion and Snapdragon 835, which is better than the XL.
I definitely got slowdowns when using my Nexus 6P. Points where the app just lagged horribly and took seconds to go from one screen to the next. On my Nokia 8 the performance is mostly fine. On my Moto G2, the app is so slow and sluggish, it's close to unusable in my eyes.
Lots of people have asked for tabbed desktop windows, e.g. for Office and for Windows Explorer. No one asked to have a touchscreen OS bolted onto their desktop experience.
On desktops, OEMs don't go around modifying the desktop icons to whatever shape they want (mostly because they aren't allowed to with Windows). On Android, they can.
Play Store apps actually *are* adaptive icons. It's just that they use a while coloured background.
And forgetting to add `file.close()` is precisely why you should use the context-manager form of opening files :)
Absolutely do it the second way. Something that the original code is missing is that you forgot to close the file. Any time you open a file, you need to close it afterwards like so:

    fin = open('relativity.txt', 'rt')
    # code goes here
    fin.close()

However, file objects are what we call *context-managers*, which means they can be used with the `with` statement. When you use  a file object as a context manager, the file automatically closes when you leave the code block.

    with open('relativity.txt', 'rt') as fin:
        # code goes here
        # more code goes here
    # file is automatically closed here

The second way is always the best way as you never have to remember to explicitly close the file, so it's not something you can ever forget to do.
The volume thing is to do with the EU - literally every device sold in the EU has it. That said, it is annoying when Android or Windows decides to randomly drop the volume below their threshold every now and again without saying anything. 
Can you not RMA? Are you still in warranty period?
A couple of things to say here

...

Your top example would have worked, you just screwed it up. This is what it should look like:

    class A:
        def __init__(self, x, y):
            # x and y must be instance variables
            self.x = x
            self.y = y
            
    class B(A):
        def add(self):
            return self.x + self.y

...

Furthermore, this is not a "has a" relationship. Inheritance is an "is a" relationship - `class B` is a subclass of `class A`.

Association (of which composition and aggregation belong to) are "has a" relationships and look like this in Python:

    class A:
        pass

    class B:
        def __init__(self):
            self.a = A()

Here, `class B` has an instance of `class A`.
When writing a class in languages like Java and C++, it is frowned upon to let users of a class access instance attributes directly (i.e. by accessing `npc.appearance` or `npc.purpose`).  If a user starts accessing instance attributes, but in the future, you need to control how your attributes are accessed, you can't do this without changing your attribute to a method and breaking the code of the other developers using your class. 

As a result, due to futureproofing against this kind of thing, Java and C++ write "getters and setters". They wrap instance attributes around methods like so,

    def getAppearance(self):
        return self.appearance

    def setAppearance(self, new_appearance):
        self.appearance = new_appearance

These are called "getters and setters" because it is through these methods that users of your class will "get" and "set" your instance attributes. And the code that you were writing resembled the "getter" pattern of Java and C++ developers.

You should NEVER use getters and setters in Python. We don't have the same worry that Java and C++ devs have. In Python, we have a feature called properties. If we ever need to control access to an instance attribute in the future, we can add properties in after the fact, which let us convert instance attributes to instance methods. 
Try encoding in UTF-8. Then go to Excel, go to Data tab and click Get Data from Text/CSV. Then, once you select your file, the File Origin dropdown lets you specify the character encoding. Change to UTF-8 and see if that works.
Pass the numpy array into `np.transpose()`.
Since your main question has been answered, I wanted to point out some other things:

---

    class npc:

You should start your class names with a capital letter to match Python's style guide. Definitely Google PEP8 and read it to see how we name things in Python.

---

    def displayAppearance(self):
        return (self.appearance)
 
    def displayPurpose(self):
        return (self.purpose)

This code is unnecessary. I'm not sure if you have come from other languages like Java or C++, but in Python we don't write getters and setters for our instance attributes. This is because we have properties, which allow us to control access to our instance attributes if we need to. 

---

    if itemGot == False:
        ...
    elif itemGot == True:
        ...

The way to state these are `if not itemGot` and `elif itemGot` respectively.

---

    print("Oh thank you, you got my ", itemList[0])

You should learn to use string formatting rather than printing strings like this. This would be better:

    print("Oh thank you, you got my {}.".format(itemList[0]))

or this (if you are on Python 3.6+):

    print(f"Oh thank you, you got my {itemList[0]}.")
That could well be it. Instead of opening a CSV file on Excel by double-clicking it, you should open up Excel first, go to Data tab and click Get Data from Text/CSV. Then, once you select your file, the File Origin dropdown lets you specify the character encoding (I would suggest changing to 1252: Western European (Windows) if you aren't sure of the correct selection).
While what you said is correct, it's important to specify that is probably the worst way of solving OP's particular problem. The correct way is to pass it and return `itemGot`, or use a class with `itemGot` as an instance variable. Beginners should be warned away from using `global`, because they tend to abuse it and use it everywhere thinking that they need it when they really don't. I should know - I used to be that person XD
test2 is actually fine. If you were to use Notepad++, and ensure that you are using UTF-8 as your character encoding, you would see the text look fine. Perhaps you are using Excel to open the file instead? (Excel uses cp1252 as default).
If you don't care about having tuples as your inner lists, instead of lists, then you should use the `list(zip(*list))` idiom.

    >>> matrix = [[13, 6], [14, 6], [12, 7], [11, 6]]
    >>> matrix2 = list(zip(*matrix))
    >>> matrix2
    [(13, 14, 12, 11), (6, 6, 7, 6)]

If it's important to have each inner list as an actual list, you have two options to do tuple conversion. Either use a comprehension:

    >>> matrix3 = list(list(x) for x in zip(*matrix))
    >>> matrix3
    [[13, 14, 12, 11], [6, 6, 7, 6]]

Or use `map`:

    >>> matrix4 = list(map(list, zip(*matrix)))
    >>> matrix4
    [[13, 14, 12, 11], [6, 6, 7, 6]]

I prefer comprehensions but what you choose is up to you.


The reason why is because those languages don't have properties. 
 [To quote Raymond Hettinger](https://youtu.be/wf-BqAjZb8M?t=28m36s), core Python developer:

> Getters and setters are what you do when you don't have descriptors. You have to do it in those languages. If you design classes in Java and in C++, and you don't make getters and setters for your attributes, you're incompetent. You're creating code that is going to be very difficult to maintain if people start using that API and you have to change access to that attribute - you won't be able to. So that is a strong rule in those languages.

> Does it apply in Python? ... We don't make getters and setters [...] because we can put properties in after the fact if we need to. A getter and setters is a hint that you are doing it wrong in Python.
But if we see how you are coding now, we can see where your logic may not be right and we can offer advice.
I'm trying to do this in my head on a mobile, so please excuse me, but I think I know what the issue is.

You are in a while loop. The first time you are in the while loop, you execute this statement:

    say = say(score0, score1)

At this point, `say` is a reference to `both()`. You call `say(score0, score1)`, this returns a tuple of two objects. But then you give it the reference of `say`. As a result, `say` no longer refers to `both()`, it refers to a tuple.

On the next iteration of the loop, when you do

    say = say(score0, score1)

again, you are trying to call `say`, but since `say` is now a tuple, you end up with nonsense and the exception that you see.
Could you post the full stacktrace for your TypeError?
I would probably jump into doing more practical work, trying to think up problems and actually writing code to solve them. Still continue with theory, though I would probably just do data structs and enough recursion to understand the theory of it.
This works for me in 3.6. I'm sure it's 3.5 as well though..

    >>> a = {1: 2}
    >>> b = {3: 4}
    >>> c = {5: 6}
    >>> d = {**a, **b, **c}
    >>> d
    {1: 2, 3: 4, 5: 6}
Here:

    us_capitals = {}
    canadian_capitals = {}
    mexican_capitals = {}
    nafta_capitals={**canadian_capitals, **mexican_capitals, **us_capitals}

This code requires Python 3.5+.
The best ways for us to help you is for you to post code examples and for us to review them.
I would say the `return self` bits are not Pythonic. It's weird seeing methods chained together on one line with dot notation but that actually both refer to the same instance. There's nothing wrong with functions returning nothing or usage of multiple lines. Here, usage of multiple lines are good as it explicitly tells you both methods are for the same instance.

Properties are great, but they are also pointless if the only thing accessing the property does is return the "private" attribute with nothing else performed. Just have a public attribute and return that. Later on, if you need to change the way the public attribute is get or set, you can then add a property and an underlying private attribute. 

This is the great thing about properties - you don't need to add them immediately like you do with getters and setters in Java. They are designed so you just add them after the fact only when you need them. If you add them in immediately, you make your code unnecessarily complex.
Fake fake fake - I own a Nokia 8 and this looks nothing like it!
Yup, definitely. It's a excellent device.
I'm surprised that's a deal breaker for you. I would just use a screen filter app like Twilight to fix that.
I don't have it quite yet on my unlocked UK TA-1012 . Hopefully it's coming soon though.
Other than the comment already here, which I agree with, I have some extra comments for you.

----

    @property
    def running(self):
        return self._running

    @property
    def turn(self):
        return self._turn

    ...

This sort of code is kinda pointless. You could remove these properties and remove the leading underscores from the instance variables and simplify the whole thing completely.

...

I don't like how most of your instance functions `return self`. It leads to statements like

    self.write_game().prompt_play()

which I found confusing when I read it at first. It seems to me that the only point is to reduce lines used. Just remove those return statements and have:

    self.write_game()
    self.prompt_play()
> But if I teach for loops before while loops, then students are more inclined to use for loops even when while loops are more appropriate. 

I feel like this situation is quite rare though? I almost never use a while loop except for `while True`, which in itself I find myself using rarely. What kind of situations have you come across where students use a for loop when a while loop would have been better?
When you have an `x or y` statement, Python will analyse the statement. If `x` is truthy, this statement will evaluate to `x`. If `x` is falsey, the statement will evaluate to `y`. Because `1` evaluates to `True` (you can check this by doing `bool(1)`), the statement `1 or 2` evaluates to `1`, so you only print `1`.
When you print a function, you print whatever it returns. If the function returns 1, printing the function prints out 1.
Why not just get the Nokia 8? I have one - it's great :)
One suggestion I would make - de-emphasise while loops, either by moving them to the back of your check-list or explicitly de-emphasising them when you teach them (mentioning that while loops should basically only be used for while True loops). I was taught while loops in my very first Python lesson, and I was taught them before for loops. As a result, I was using while loops for EVERYTHING like an idiot, when I should have been using for loops for everything instead.
More likely the latter, I would think.
I'm not sure how useful it is asking people the specific coding questions they received, because the chance of you getting those same questions are minimal. You should definitely make sure you have solutions to the classic questions, like fizzbuzz, bubble sort, binary search tree and others, but afterwards you just have to rely on your programming skills to help you come across unfamiliar questions.

I would say - revise the key core Python concepts, and make sure you can write Python code properly on paper if asked.  
It's a lot more effort to analyse code than it is to write it yourself, but then it's a lot of effort to personally analyse code for all the third-party libraries you might want to use. It's just not possible to do so - we don't have the time.

I think a good happy-medium between only using std library packages and using all third-party packages is to use the ones that the Python community tend to use a lot and trust. Ones like requests, BeautifulSoup, pytest, openpyxl, numpy, pandas and others. I would recommend installing Anaconda, which contains the standard library but also almost all of these very popular third-party packages. 
Your flair suggests you are using Python 2, yes? If you are using Python 2, you should switch to using Python 3. :)

Failing that, you should change `input()` to `raw_input()`.
Code is working as intended. The default string representation of an object is what you see there. Your `Student` instance is successfully being incorporated into the list within the `Course` instance.

If you want to change the string representation of your object within lists, you will need to override the `__repr__()` special method within the `Student` class.

    class Student:
        def __init__(self, Name):
            self.name = Name

        def __repr__(self):
            return self.name
Fair point, yours is a better solution to grab a random character from an abnormal range of characters. 
* Your code prints a random lowercase letter, not a random character
* If you want to get a random lowercase letter, you should just import `string.ascii_lowercase` and use the `random.choice()` function directly on that. 
    from string import printable
    from random import choice

    while True:
        print(choice(printable))
I had neither and I got a Python job within 1 month of my graduation ceremony.
I don't believe that's true, I think Decimal type can handle values far larger.
If you need precise comparison of decimals, consider switching from floats to the Decimal type (which can be imported from decimal in the standard library).
Yeah, I'd rather just not play the game at all and play games that don't resort to BS microtransaction tactics and behaviour.
Same thing with the Rayman mobile games. Rayman Jungle Run was a really nice mobile "infinite-runner" type game, kind of like Super Mario Run. 

Then Rayman Fiesta Run appeared, and whilst it was slightly better than Jungle Run, micro-transactions started to creep their way in. Micro-transactions to get powerups to help complete a level. I'm fine with those kind of micro-transactions though, as "real" gamers will see it as an insult to pay that money and will muscle through the levels without powerups instead.

And then Rayman Adventures came out. It should have been a better game than the above two as I preferred the level content, but it was completely ruined by micro-transactions and a timer to limit how much you can play in one go (but of course you can pay to reduce the timer). A good game ruined by micro-transactions. So sad.
(They are referencing Nintendo 64.)
It's winter and I live in the UK, what sunshine? :P
TIL the best editor for me is Notepad.
If you want, I can take a quick look at it. You can put it on pastebin and I'll try to see if I can give you any pointers.
I have worked with many such real-life examples, though I can't show you the exact code for obvious reasons. 

My most recent experience with such code is where we have a class that does some work, but there's 100 different situations in which we use the class, each way slightly different from the next. So we have a dictionary that links the 100 situations to 100 different arguments to be passed to the class, and a function that access this dict. You pass in a situation, the function looks up the situation in the dictionary, grabs the associated argument, and passes this into the class and instantiates it. When we add situation 101, it's as simple as modifying the dictionary to add another key-value pair.

Of course, a dict of length 100 is not the prettiest. But it's a good solution because it's reusable. If I want to create a class_b that does something only slightly different to the first class, it's pretty easy to reuse the dict I created. And because you are separating the data from the code, you can also place the dict in a separate config module and import it into the module that contains your main logic, which keeps the logic module cleaner looking.

The alternative is a block of `if...elif...elif` that is 200 lines long at least. But it's not just about code lines - I argue that such a construct is less flexible and uglier for the above reasons.
The above solution can be modified to deal with the issues you mentioned.

> What if you need to pass a varying number of arguments to each function? 

Instead of the dictionary values being just the function reference, they can be a tuple containing the function reference and associated arguments.

>What do you do if your app changes and one of the cases needs to invoke more than one function?

Same as above. For the dictionary values, you can use a tuple to contain the numerous function definitions. Then, when you grab a specific dictionary value, you iterate over the functions in the tuple and call each one.

> What if your functions return different values that need to be stored in different variables for later use?

Again, extend the dictionary value. Use a tuple or another dictionary to contain both the function reference and each variable that needs to be changed.


You might argue that the above solutions will end up looking ugly and/or complex. If all you have are 3 `elif` statements, then it's probably better to go down the `elif` route. But if you will end up having 30 `elif` statements, then the dictionary route will end up looking far cleaner.
If you are going to be having different pieces of information for each country, then you should probably just use a dict of dicts instead.

You don't need a lot of if conditions to do what you say. When the user types in a country, you just lookup the correct sub-dict and print out the key-value pairs from there.
Use the 2to3 standard library package to convert the code. It looks like this is pretty trivial to convert manually, I think it's just the print statements that need to be converted to functions, but you can use the 2to3 package to convert it programmatically.
Let's say you have a dictionary of countries. Each key is a country. If each value for the country will contain the exact same three pieces of information (landscape, hdi, language), then you could make the dictionary value a tuple that contains these three values. To make it simpler, you could use a namedtuple as the dictionary values to contain these three values.

    from collections import namedtuple

    Country = namedtuple('Country', 'land hdi lang')

    countries = {
        'india': Country('mountainous', 'low', 'hindi'),
        'netherlands': Country('flat', 'high', 'dutch'),
    }

Then you access the info using dot notation

    >>> countries['india'].land
    'mountainous'
When you have a long list of `if...elif...elif` statements, think about using a data structure to simplify things. Usually you would use a dictionary, but because you are starting from x = 0, you would be better off using a list. Put all your functions in a list, then grab the correct function from the list and call it.

    x_list = [mode0, mode1, mode2, mode3, mode4, mode5, mode6, mode7,
              mode8, mode9, mode10, mode11, mode12, mode13, mode14, mode15]
    number = x_list[x]()

I'm assuming that your mode functions are distinct functions. If the mode functions are actually similar to each other, then you could probably refactor more.
In both examples, the function objects are created. As I understand it, all the dictionary is doing is storing references to those objects. Is that technically more memory being used? Sure. Does it matter? Not at all. This amount of memory usage is very little but you gain more readable and reusable code from it.

To your second point - I say, so what? I'm not sure whether your concern is the author of the code screwing things up, or other users of the code screwing things up, but in both situations, it's not a problem. 

If your concern is the author of the code being able to change the dictionary - I'd argue that's a good thing as it shows this construct is easily modifiable and reusable. Of course, they could change it incorrectly, but then they could change anything else in the script incorrectly, so this isn't worth considering.

If your concern is other users of the code changing the dictionary and screwing things up - I remind you of the Python mantra - "we're all consenting adults here". Everything is intended to be public and modified in Python - if someone else wants to change that dictionary, then we let them do it as they have made that choice. It's very possible they have a good reason for doing it and we should not seek to block that.
I only just saw your comment about the brackets, haha. The answer to that is easy. 

In my example, I was mapping ints to functions. `a`, `b`, `c` - these were all references to functions (look carefully at the very first example with the `elifs` - you'll see these were functions). When you grab the function from the mapping dictionary, you then have to call the function - that's where the `()` brackets come into it.

In your example, you are mapping ints to ints. Obviously, you can't call an int - that's just nonsense. So, you must leave the `()` brackets out when you grab the int from the mapping dictionary.
That "feeling" is what we call a code smell. When you look at the code and it smells of something bad. The code may not necessarily be incorrect, but there's something wrong with it. That's when you know it's a good time to refactor.

Anyhow, good luck with your refactor - I hope it goes well and I'm happy that my comment taught you something :)
Yup.
In addition to the other reasons given (clarity, easy to edit, etc.), another one is better reusability. 

Say you want to reuse the above logic elsewhere. With the dictionary, all you have to do is type `mapping[x]()` and you are golden. You can't achieve the same thing with the conditional code block on its own. You would either have to copy and paste that code block (not very nice) or place the code block in its own function, which would allow you to reuse it. The latter would be slightly better, but it's a layer of indirection that is not required for the dictionary solution.

Now, say you need to reuse the conditional block later in your code, but you need to change it slightly. Maybe you need to add an extra condition, i.e. `if x == 9: f()`. Maybe you need to change a condition, i.e. `if x == 4: h()`. Modifying the dictionary is child's play. Modifying that conditional code block? Not so much.
I don't think the functions are that bad, honestly. The bigger issue to me is that `if...elif...elif` block which could be refactored, and the functions actually can help with that:

    operator_dict = {
        '+': add,
        '-': sub,
        '*': mul,
        '/': div,
    }

    value = operator_dict[operation](num1, num2)
    print(value)

---


EDIT: you could make the whole thing even more concise by using lambda functions here - this would let you remove your function definitions up top:

    operator_dict = {
        '+': 
            lambda x, y: x + y,
        '-': 
            lambda x, y: x - y,
        '*': 
            lambda x, y: x * y,
        '/': 
            lambda x, y: x / y,
    }

    value = operator_dict[operation](num1, num2)
    print(value)

Admittedly, this can make things look a little complex though, esp with the many colons being used.
If you want a function to store a certain result in a variable when you call it, you use the `return` keyword to do that.

    def func_a():
        return "a"

    var = func_a()   # stores the string "a" in var
    print(var)       # prints a
You could have a `Rectangle` class that lets the user pass in two values, and from there create a subclass called `Square` that lets the user pass in one value only.
Ah, whoops! I make that error all the time XD. Will fix.
The solution posted here is good, but I have a question for you - why do you want the user to be able to pass in two values in the first place? If they pass in different values for width and height, you are going to have to deal with that in some form or another (probably by raising an exception) because you won't be able to construct a valid square from that. Seems to me that the simplest approach is just to restrict the user to passing in one value.
Then I think your approach is fine.
I think that the approach you are taking is fine. In the above situation, your `does` dict is a little pointless because all the directions use the `move` function though. That dictionary could easily be removed to simplify your code.
I'd like to think Python will not let you do this, but I'm not sure.
For me, it's the long block of `if...elif...elif` statements. That seems to be a common one on this subreddit.

    if x == 4:
        a()
    elif x == 5:
        b()
    elif x == 6:
        c()
    elif x == 7:
        d()
    elif x == 8:
        e()

And so on. Those of us with some Python experience know that this is a code smell. To those of you reading who might be thinking to yourself ”this is how I write my code", whenever you start to write code like this, think about the common elements that you can abstract away. In particular, think if you can use a dictionary to do this. The below code is far better:

    mapping = {
        4: a,
        5: b,
        6: c,
        7: d,
        8: e,
    }

    mapping[x]()

Remember, functions are first-class objects. You can store them in dictionaries, retrieve them later and then call them afterwards.
When you pass an object to `len()`, what happens is that `object.__len__()` is called, which contains the underlying code of how the length of the object is calculated.
`[None]` is exactly what it looks like - a one element list where the first element is a `None`. In this case, the code is using list multiplication. When you multiply a list by an int, you get a bigger list with repeating elements. The point of `[None] * target_size-len(data)` is to end up with a list of `None`s, i.e. `[None, None, None, None, ... ]`.
Break the project down into individual pieces, if you can. 

Then do one piece and jump headfirst into it. Don't think about problems and issues - just try to build that individual piece as simply as you can.
The part where they criticise the specs of the Switch whilst recommending the 2DS XL over the Switch in the same sentence got a chuckle out of me. 
Defining a class inside the while loop is almost certainly the wrong thing to do. I'm certain there's a simpler way to achieve the thing you want, but we can only suggest what this is if we can see the full code (I suggest just dumping the entire script on pastebin.com and giving us the link).
So, I am not fully aware of the role operations play, I admit. I guess if you are in DevOps/ops, then I might give you a pass too :P Depends how much coding you actually did, I guess.
`>>> fruits = "['apple', 'orange', 'banana']"`

    >>> import ast
    >>> fruits = ast.literal_eval(fruits)
    >>> fruits
    ['apple', 'orange', 'banana']
    >>> fruits[1]
    'orange'

Source: https://stackoverflow.com/questions/10775894/converting-a-string-representation-of-a-list-into-an-actual-list-object
Since a good explanation is given for properties, perhaps I can tackle getattr (and setattr by extension).

Let's use your example - you have an object `car` with the attribute `wheels`.

There are two ways to access this:

    car.wheels
    getattr(car, 'wheels')

So why would you use the second form? Well, look at the second parameter - `wheels` is a string. Because the second parameter is a string, you can get attributes dynamically from an object.

Imagine you wanted to have user input to allow the user to grab an attribute from `car` and print out that attribute. (A contrived example, I know.) You could do this:

    attribute = input("Type car attribute")
    print(getattr(car, attribute))

If the user types in `wheels`, then this script prints out `car.wheels`. But if the user types in `doors`, then this script prints out `car.doors`. I hope you can see - because we are using a string to access the object's attribute, you can do more dynamic things with this functionality.
> From the reading I've done the @property is the pythonic way of creating getter and setter methods. 

Almost. @property is a Python feature specifically designed so you *don't* have to create getters and setters. You just set object attributes and, if it turns out you need to change the way the attribute is calculated, you use @property.
The Cat in the Hat
I had wanted to replicate the Quantum look in Chrome, but it's basically not possible.

You can't make Chrome tabs more rectangular like Firefox tabs.

You can't make the colour of Chrome background tabs change depending on whether the Chrome window is active or inactive, which is what Firefox Quantum does.

You also can't colour Chrome background tabs as the Windows accent colour, which is what Firefox Quantum does too.

tl;dr: you can't do shit to make Chrome look like Firefox Quantum, not until Chrome devs enhance themes (which is never).
No worries :) if you have any more questions don't hesitate to PM me :)
Thank you very much for your kind words :)

Github, Bitbucket, etc. should be fine for any code projects. However, it's also a good idea to bring a copy of your code to any interviews you have. My current co-worker flunked his first technical interview, but he had his dissertation code on a CD which he then gave to his interviewer afterwards, as a way of saying "I'm not an idiot, here's proof I can actually code". This saved him and he was allowed to move onto the next stage of the application process.
I am honestly surprised that there exists established professional software developers that don't know about unit tests.

If you are new to the world of programming, then fine, you get a pass. If you have only ever developed alone as a professional developer, then it's also possible to have heard of unit testing but such people are still incompetent IMO and should make it their no 1 priority to learn it immediately. 

Everyone else who works in teams should know about unit testing. If you have worked in a software team for more than a few weeks and you don't know about unit testing, then that sets alarm bells ringing. It tells me that not only is the developer incompetent, but the team and maybe even the departmental culture is incorrect too. It suggests that the team itself is not in the habit of writing tests, or they do not call out developers who do not write tests, which is a worrying sign.

On the subject of pytest, definitely look into it. The tests you write often look  more Pythonic because you aren't forced into writing a unittest.TestCase subclass for every one of your tests. The minimum for a test is a top-level function. Also, you use the built-in `assert` keyword; none of this `self.assertEquals` stuff. Lastly, you don't have to rewrite existing tests. Pytest supports unittest nomenclature so you can keep your existing tests working while you write new tests in the pytest style.
So, for me my current job literally fell into my inbox. No joke - one day I woke up and there the job opportunity was. It happened because I uploaded my CV to job search sites and elected to make my CV visible to recruiters. A recruiter found my CV by searching for Python (on my CV, I wrote about my Python programming as part of my undergraduate degree dissertation) and they sent me an email to see if I would be interested. Two interviews later, I scored my first ever job, and I started work as a Python programmer. 

Moral of the story - highlight any Python experience you have on your CV and make sure as many people as possible see it. If you don't have Python experience, highlight that you'd be interested in the job plus anything you've done outside of work to show that. As long as you get the Python keyword on there somehow, this will help recruiters find you.
How what?
ISIS was renamed to Softcard (for obvious reasons) and then bought by Google to be integrated into Android Pay.
Is it as performant as the iPhone though? Two years ago I upgraded from the Moto G2 to the Nexus 6P. The difference was night and day. That's often the problem with budget phones.
It's not just a phone though. You can text, play games, browse the web, take pictures, view maps and use sat nav, and do countless other things through apps, *and* use it as a phone. It's a pocket-sized computer, for most people the main computer they use and for many people the only computer they use. Shelling out a little bit of money to buy a decent one makes sense.
I often write the test before the code because I *don't* know the code, not because I do. But when I write the test, it forces me to think "what exactly do I want to achieve here?". The test helps point me in the right direction with regards to the code I have to write.
Only if you watched the extended version for all three movies consecutively.
To be fair, it's taken Firefox close to ten years to become faster than Chrome.
My only disappointment is that they did one line rather than the whole song.
I use pytest mostly because I don't want to use unittest nomenclature to write my tests. Writing tests in the pytest style is often more Pythonic. You are not forced to write classes for tests (you can just use top-level functions) and you use the built-in `assert` keyword rather than `self.assertEquals`.
> Use the unittest package to construct tests for your code. 

Actually I'd recommend pytest over unittest, unless the person is constrained to only use certain libraries.
I'm not working on any Python this week, I have 10 days annual leave to enjoy off from my Python job :) 
If you are coding somewhere where you don't have significant constraints on memory and CPU, or the code you write is not significantly time-sensitive, then using Python is just fine. It's important to remember that, what you lose in pure performance from using Python, you gain in "developer time". Developers can write a solution in Python much faster than they could in C, and with developers being an expensive resource, this metric is something that many companies care very deeply about.
I guess it's because the thread is about senior programmers giving tips and tricks to junior programmers, and writing unit tests isn't a "tip" or a "trick", it's mandatory. If you are a professional junior programmer and you aren't writing unit tests, you are incompetent, end of story.

With that said, there are two tips I would suggest with regards to unit tests:

* Write unit tests regardless of what you are doing. Unit tests are mandatory in a professional setting, but even if you are writing the simplest of pet projects you should write them. Unit tests and test-driven development are extremely useful if you want to code something but you are unsure how to start. Starting off with a basic test that captures what you want to achieve will often help point you in the right direction.
* Use `pytest` instead of `unittest`. Pytest is just so much nicer IMO. There are many benefits, but my fave is that there is so much less boilerplate code involved. It makes it much nicer to write tests when all you need is a top-level function rather than having to write out a class.
If you are coding Python in your spare time, it's fine. Actually, I'd encourage it if what you want to do is understand how things work under the hood. 

However, if you are coding for a degree or coding professionally, then trying to use no libraries is almost always a waste of time. Take calculating the log of a number. It's very simple to just do `import math; math.log(1024, 2)` . Writing your own algorithm to do that is an utter waste of time when you should be spending your time writing code to tackle your main objective. The only exception to this is if your main objective to write a math calculation module.
Most of the loops I write are simple loops and it's much cleaner to use a list comprehension as you condense 3 lines of code into one line. Loops are better for more complex functionality though, I agree with that.
    


That seems like a really bad idea. You'll have a keyboard that's too big to be used with two thumbs, so you'll struggle to use it like a BlackBerry, but a keyboard that's too small to be used with touch typing.
Apologies, I'm not familiar with using these modules, I just know that they are the ones you should use. You'll have to look at their documentation to understand how to use them to parse the XML file.
BeautifulSoup doesn't parse XML on its own. You need to use something like the xml.etree.ElementTree standard library module or the lxml.etree third-party module (I recommend using lxml).
You should go for the first one. The first one is more Pythonic and easier to read. 

However, if you are finding that your `if...elif...elif...else` statements are taking up too many lines, you may have a code smell that indicates you could refactor the code block in a different way instead. Could you post the whole code block for us, please?
It's acceptable to be upfront about height preferences unlike certain other preferences. No one says "don't message me if you have a weak jawline" or "I'm sorry I don't want to date you, I have a thing for guys with nice eyes".
That's the point - they know you don't have the time to play that much so you either give up or spend money.
KitKat was released 3-4 years ago, which is an age when it comes to mobile OSs. If you pit a more modern iPhone or Android phone against something like the 950 or Elite X3, things may be different.
Hence why I specified "most apps" :3 . I know that ReddPlanet and Readit and Groove and others had that capability but most apps do not. In comparison, on Android it's very very rare that I encounter a navigation drawer that can't be open with swipe from left edge. Usually it's only websites and apps that are just website-wrappers which suffer from this.
My biggest problem with it was that in most apps, you couldn't swipe from the left edge to open the navigation drawer, which really hurt one-handed usage.
At my workplace, I know 5 other people that have Nintendo Switches, on a floor with 30 people at most. But then, I work with a bunch of software devs so that factor may skew things :3
Certain games need the JoyCons separate. 1 2 Switch can't be played with JoyCons perma-attached to the Switch. Games like Wii Bowling would be impossible to play as well, if Nintendo ever wanted to port that over.
My experience is the opposite - I need the grip otherwise my hand cramps up trying to hold the JoyCons for too long. But these days I just use the Pro Controller instead.
Adding shruggies and Zoidberg Easter eggs - clearly the hallmark of an enterprise-focused app.
But Snapchat need to find a way to monetise their app. It's either sponsored articles, ads, or subscription.
Your first statement is contradictory. If you have to get used to Snapchat before you can understand how it works, then almost by definition it is not intuitive.
I doubt they'll do this, the reason they do this is to prevent people using root to take screenshots without notifying the other person.
Those news stories generate revenue for Snapchat, and given how badly Snap Inc is bleeding money, they are never going to remove them.
Go to chrome://flags, scroll down to Custom-drawn Windows 10 Titlebar and press Enable. This will enable default window controls for themes.
It's not really another layer - to most people, it's just Python with all the popular third-party modules included in one installation. That's why I like it - I install one executable and get pytest, BeautifulSoup, numpy, matplotlib, openpyxl and others included automatically.
I think it's more that sports tends to be "real", and wrestling is a sport. So, it feels odd at first to see a sport that is scripted and has storylines and so forth. That's where all those sorts of comments come from.
LG and Samsung care about differentiation. They need to stand out from the crowd. If Samsung creates a launcher that consumers like, then that's one extra reason to get a Samsung over another Android phone. If Samsung uses a basic launcher that literally anyone can use, even though it's great for the consumer, it's bad for Samsung because they have lost an opportunity for differentiation.
It's useful for full screen content, such as watching videos.
Problem is that the bezels will have to get bigger for a home button, which is the opposite trend to the way phones are going these data.
And they couldn't tell it's a different console in part due to the name. Wii U doesn't mean anything; Wii 2 is quite clear in the name that it's a successor to Wii.
Microsoft would actually have to release phones to make money. No, this is MS looking for more saps to do their testing for them.
This is the thing though - it's a preference, not a sexuality. Why it's labelled as a sexuality is baffling to me.
The problem is that a) sometimes you don't even get "basic info", and b) asking for more information doesn't get a response because the girl gets too many messages anyway.
What it also means is that the Qi standard will be guaranteed. Anywhere that has wireless charging will *have* to have Qi charging now that the iPhone is getting it. I think PMA will soon be irrelevant because of Apple's choice.
And then they cut it out for Windows 10 Mobile, moving to hamburger menus with no ability to swipe from left edge to open. They went from having the best one-handed use to the worst in one fell swoop.
That doesn't even fit here - Macron didn't impress a classmate, he impressed his teacher.
Also, with Jurassic Park, he couldn't keep Ian Malcolm dead. He retconned Malcolm's death for The Lost World. I thought that was a little poor when I read the books. But otherwise I thought the books were good.
Download and install Chrome extension source viewer. Then use it to inspect the theme at its Chrome Web Store listing. From there, you should be able to identify and extract the picture.
As the author of that theme, I approve :3
Are you aware of how to do screenshots from Now on Tap/Google Assistant? Press and hold Home and then press Share.
If you use Pixel Launcher, you can force circles. [Here](https://forum.xda-developers.com/android/apps-games/app-rootless-pixel-2-launcher-google-t3688393) you can install it. Then within the Launcher settings you can switch from rounded square to circle.

The icon normalisation within Pixel Launcher as well as the ability to switch from square to circle does a huge amount in making the adaptive icons match with the non-adaptive icons. Oreo icons just look like garbage in Google Now Launcher by comparison.
Sadly I do, I program in Python 2.6 ;_;
That's the one everybody ignores. People who religiously stick to PEP 8 will make an exception for the 79 character rule. Even Raymond Hettinger, Python core developer, says to ignore that one. 
You have to be consistent in Python 2 too. If you mix up spaces and tabs, your code may not work properly. It's just Python 2 won't raise the indentation error, it'll raise a totally different error and if you are beginner you will have hell of a time trying to debug it.
Keep two copies of your resume - your real one that you use to apply to the jobs you actually want, and a crappy one that you use to apply to those bad jobs. You have to sabotage your CV if you are overqualified, sometimes.
While it sucks for the overqualified person, can you really blame the employer? Obviously employers would rather take someone who is more permanent. The trick is to realise that and dumb down your resume to compensate.
It's tricky. You just have to motivate yourself to take the first steps. Easier said than done, I know, but if you don't do it weeks and even months will pass you by in the blink of an eye. I know what it's like because I was in that very position. I was fresh out of uni and it was summer and I was all like "It's summer, I've finished my degree, I should relax instead of stressing about job hunting". Then May turns into June, then July and so on and before I know it it's the middle of September and I've applied to probably 2 jobs. My friend noticing what was happening, asked me to apply to 5 jobs that very day and was *so disappointed* in me when I told her the next day only applied to 1 job. It took that to give me the kick up the backside and start really applying for jobs.
Google doesn't allow Android dual boot devices. Microsoft could do it but they wouldn't be allowed access to Play Store and Google apps. Hence it's a no go.
Unless you had the audacity to like the Big Bang Theory, and then suddenly they weren't chill. Go do a Reddit search for Big Bang Theory on /r/community and see just how many posts are upvoted there that hate on the show.
Actually, the whole reason they reduced the OneDrive storage had little to do with abusers. The real reason was explained by Chris Capossella, Microsoft's chief marketing officer, on an episode of the Windows Weekly podcast. To quote some of what he said:

> “OneDrive takeback is a way to anger a bunch of diehard fans, particularly in the way we did it. In that case, if anyone had seen the math, I don’t think they would have questioned the economics.

> Why did we put ourselves there in the first place, that was another mistake that we had made a year earlier. The economics were totally unsustainable, the way we did the communications was very rushed, because of a major publication that was going to publish something that was very damaging, and was not true. And so we felt like we had to get in front of it and we just weren’t ready.

> We had given ourselves a couple more months to get everything lined up, all in one fell swoop. OneDrive for Business, OneDrive for consumer, how we grandfathered people, blah, blah blah.

>.We just were not ready. But the alternative of having a very damaging, borderline false story run in a massive publication, Frank (Frank Shaw, Microsoft’s head of communications) and I just couldn’t let that happen. We just didn’t do a good enough job in the sprint to beat the story to get the communications in the shape that they needed to be.

> The economic decision was easy. We made the economic decision, incorrectly, a year earlier, and then when we saw the usage just take off and you have 400 million or whatever it is, and you’re upgrading a gazillion Windows 10 machines, and they’re all using OneDrive, which is great, but you’ve got to use it in a way that’s economically sustainable. Those were some of the things that went into it.”

Source: https://youtu.be/rd8na8DEsZo , around the 1h 7 min mark.
Chromebooks have the offer of 100 GB. But it's only for two years. I know of no Android devices that have something similar, not even Pixel has that (though admittedly Pixel has unlimited storage of photos at original quality, which is pretty cool).
Not even Google can offer 25 GB. As for 15? Who knows. I'm not privy to the knowledge of how big their cloud is so I don't genuinely know if they can offer that.
I could literally repeat the same point I had above and just replace Mega for Box. Box is not preinstalled on hundreds of millions of devices - this is why they can offer you 50 GB. Have you ever wondered why Apple, Microsoft and Google can only offer you 5-15 GB for free when they are many, many times bigger and richer than Mega or Box?
Or you know, you could not care about whether this is a bug or not and just install VLC instead. I find it funny people on this sub, who are apparently meant to be "tech-savvy", still use WMP.
MEGA isn't preinstalled on hundreds of millions of PCs. OneDrive is. If MEGA was as popular as OneDrive is, there's no way they could offer 50 GB storage for free. Not even Google can offer that.
When you say "supports wide-screen", what do you mean exactly?
It's not just one season though, the criticism of "too forced" was true even toward the end of the Top Gear CHM era. It's just that The Grand Tour continued that decline.
Your biggest priority is to sort out those global variables pronto. But you already know that, so a couple of other things to note:

---

An explanation of a function as the first-line is usually a docstring:
     
     """This is a docstring."""

instead of a comment:

     # This is a comment.

It's not a big deal since you are the only one editing your code. However, if this was shared code that someone else was trying to debug, they can access the function explanation by typing `function.__doc__`. They can only do this if it is a docstring, not if it is a comment.

---

There are lots of places you are using string concatenation, such as:

     print('I have tested ' + str(global_testing_number) + ' ' + str(global_iterations) + ' times,')

You should look to using string formatting instead. If you are using Python 3.6, research how to use f strings like this: 

     print(f"I have tested {global_testing_number} {global_iterations} times,")

If you are using an older version of Python, use `str.format()` like this:

     print("I have tested {} {} times,".format(global_testing_number, global_iterations)

or like this:

     print("I have tested {global_testing_number} {global_iterations} times,".format(global_testing_number=global_testing_number, global_iterations=global_iterations))


Readability is basically the main reason for these naming conventions. When you have different naming conventions for different things (UpperCamelCase for classes, snake_case for variables and functions, UPPERCASE for top level constants, etc) then it's easier to tell at a glance which is which.
I think that they changed that for the next feature update, which is a good thing at least.
I think it's for devices that have a SIM card. But yeah, that is something like less than 1% of devices, so it's crazy they don't let you uninstall that one.
I disagree. Even if it's used in a small scope, it should be at the top. PEP 8 is clear on this. The only reason to have imports inline is to prevent a circular dependency.
Try not to use global variables if you can avoid them :) Global constants are usually fine, either at the top-level of your script or in a config file, but avoid using global variables.

For your question, it's really your call. Do you think your other game is very similar to the first, or do you think it's truly a different game? If the former, then look into adapting the first game; if the latter, then build the game from scratch. But if you end up getting stuck on breaking game 1 up into functions, don't be afraid to cut your losses and start from scratch.


Your program is basically one big script with no modularity to it. Consider using functions to split out your program into different components. Consider using a class to represent the stats of the player, with methods to represent stat changes. Right now, because you haven't used functions or classes at all, making any changes to the game or extending it becomes much harder.

Also consider adding unittests to check that your program does what you expect it to do; right now the only way someone can tell that your script does what it should do is by running the game, but adding tests is an additional layer of confidence that your game works. 
I just have PEP 8 stuff to tell you: variable and function names should be snake_case, not camelCase, top-level constants should be in capital letters and function explanations should be docstrings, not regular comments. Other than that, looks fine :)
I think in this context, developers = Python core developers and users = normal Python devs.
Makes sense. That's probably the best way of going about it. A lot of people keep their code exclusively in Jupyter notebooks though, which I think isn't the best in the long term.
The problem with Jupyter is that, as soon as you move from a single script to a multi-script project, Jupyter notebooks get in the way. You can't import functions/classes from one notebook to another out of the box, you need to write code simply to get that working. Once you start getting into the realms of multi-module projects, you should use .py files instead like everyone else because it's just better. Instead of relying on Jupyter notebook cells for modularity, try instead to use functions and modules to achieve the same thing if not already. This will allow for proper automated testing within a separate script.
I'm the author of these themes, I'm glad you liked them :)
Hey there, thanks a bunch for linking to my themes :)
Who's they? If you mean launcher developer, then my question is what RSS feed or API? If you mean the app developer, my point is that most will not do anything unless the launcher is super popular, and even then they probably will do nothing.
In the top level of the numpy package, you will have an `__init__.py` file. It is very likely that, within that `__init__.py` file, there is a statement like `from core.multiarray import zeros` or `from core.multiarray import *` or something like that, which hoists the class up into the top level of the package.

You can do the same thing: create a top-level `__init__.py` within your BES package and have `from function import test` or something similar. 
Still pretty hit and miss though. There's some stuff that you have as notifications that you don't want as Live Tile info, and vice versa.
Reality

Totally legit story, totally bogus expectation :)
FireOS succeeded because mobile apps aren't as critical to tablets as they are to phones, and because the tablets in question are cheap tablets. As soon as Amazon tried to make a high end phone with Fire OS, it tanked horribly.
Forking Android is pointless. With no access to the Play Store, Microsoft would have another Windows phone on their hands (i.e. lack of apps).
The point is things like bookmark and history sync. 99% of people using web browsers have literally no idea what a rendering engine is.
You can't *really* do proper Live Tiles on iOS/Android. You can have static tiles and you can try to shoehorn widgets onto tiles. But if you want things like a news app to show you the latest headlines or an email app to show you your last unread email, the app developer would need to play ball and integrate Microsoft Launcher-specific features into their app code. *Very* few developers would be willing to do this unless Microsoft gets enough popularity for their launcher
If you look at his YouTube channel, it looks like he's been trying a whole bunch of video ideas, and these medical ones seem to be very recent but way more successful than any of the other stuff he's done.
This is not hindsight. Almost everyone else got the memo, it's why Windows phone sales fell off a cliff in the last 1-2 years. The die-hard fans are the only ones who seem unable to see this obvious thing.
There never was a clear announcement, but the writing has been on the wall for a LONG time now. If you couldn't tell that the OS was slowly dying a painful death and that you should have switched, I don't know what to tell you.
Of course such a person wouldn't care what Google wants you to do with the device. My point is that it's a failure from Google's point of view. They've failed to convince that person that Chrome OS is useful on the high end, and that is the exact opposite of what Google set out to achieve.
Look, I like Chrome OS. I like the "less is more" thing going on with it. But my point is that all of that stuff you mention you can do, is also stuff you can do on a $350 Chromebook. You haven't mentioned a single thing that you need that Pixelbook for. And, as much as you might dislike Windows laptops, you have to admit that a $1000 Windows laptop lets you do a hell of a lot more stuff than a $1000 Chrome OS machine.
I can understand it being a lovely laptop, but it just seems like an awful waste of money. There are laptops out there that are lovely and actually let you utilise their hardware properly as well. 
$1000 Linux machine makes sense, if that's what you want to do with  the Pixelbook. But it's absolutely not what Google wants you to do with the device.
If you have a "real computer" at home, do you really need a $1000 Chromebook on the go? What do you need that extra hardware for when you have an OS that barely lets you use it properly?

Instant tethering is nice, but from reading news articles it seems that it is a generic Chrome OS feature rather than a feature exclusive to Pixelbook. 
A $350 Chromebook makes sense. A $1000 Chromebook is just silly. I like Chrome OS but it makes zero sense on high end devices.
* Testing gives you confidence that your code works exactly as you expect it to. You just run your tests and if they pass, everything should be good.
* Manual testing like you describe is important but they are only one-time events. Automatic tests don't go away and you can run them anytime.
* Testing helps catch errors you don't foresee when you start to make changes to the code, and they catch errors ahead of running the code.
* Writing tests can be useful if you don't quite know how to write a piece of code. You can write a test that defines what you want a class/function to do, and then write the code to make that test pass, and then rinse and repeat. It's called TDD - test driven development.
* When you work on larger projects, tests are basically mandatory. Other people will run your code and they want to have the confidence that it will run fine and that the code won't fall over onto the ground. Passing tests give others that confidence.
This isn't really a Python question. Your question is probably more suited to a Bioinformatics forum.
What you basically want is a laptop with a SIM card slot. Surface Pro has LTE with a nano-SIM card slot. Get that :)
Even if they pushed Meego to be competitive with iOS/Android, it would have had the exact same problem as Windows Phone - lack of apps.
In this design, you have to compromise. All the interesting hardware can only be inside the phone. That means that it will have a worse price-performance ratio then comparable slim laptops which are able to take advantage of a lot more space. 

What are you gaining for that compromise? A Windows 10 Mobile? Most people will not see that as a compromise worth having. They would rather get a laptop that has a better price-performance ratio and get a phone that has a mainstream OS with apps they can use, rather than get a weaker laptop and phone with unpopular OS
A lot of people who pirated it instead.
If it's running full Windows 10 on ARM it would be able to run x86. Running anything else would be stupid for Microsoft.
Headers are pretty easy in Microsoft Word. Word has default formatting for normal content, headers, quotes, emphasis text, etc. so creating a header is as simple as clicking Header on the ribbon.
To be fair, there are differences. The Atrix could only run Android apps that were designed for a phone/tablet form factor. A phone running Windows 10 on ARM would be able to run full x86 applications through emulation.

Not that it would make a difference to how successful a Surface Phone would be, but there you go.
Selling it as a dockable PC will never work. Who wants to buy a phone that doesn't work that well as a phone, just as a weak laptop?
Can you not do unpaid volunteering? Most work experience students do is a just a few weeks unpaid work.
This only really applies at the top end, say if you want to do law or medicine, or get into Oxford or Cambridge. You don't have to work jobs, but say for medicine, if you don't have *some* form of volunteering or work experience at a hospital/surgery then it becomes very difficult to get a seat, even with stellar grades.
Hey there :)

If you find a theme you like but that themes the titlebar, you can go to chrome://flags, scroll down to Custom-drawn Windows 10 Titlebar and press Enable. This will enable titlebar colour but in the Windows 10 style.
Can we see all the files in your program? (Perhaps put them on pastebin). Then it is easier to give you the best approach.
No worries. If you have any questions or want me to check your code feel free to PM me.
I think that the Python Pluralsight courses are excellent. My favourites without a doubt are Python Fundamentals and Python Beyond the Basics by Austin Bingham and Dr Robert Smallshire. If you do that two courses you will have a really solid grounding in Python.
You can't just open a folder. You need to navigate to the folder, get a list of filenames in that folder, iterate over the list to find .txt filenames, and once you come across a .txt file *then* open that specific file and print out its contents.

In order to navigate to a folder and look at its contents, you will need to use the `os` module.
You seriously have to get a lot better at variable names. At the very least, use snake_case rather than squashingtogethereveryword.
Jupyter notebooks are good if you are a beginner. I did my entire undergrad project in Jupyter only. However, once you start creating projects with multiple files and imports and tests and whatnot, I find the Notebook structure to get in the way. It's better just using .py files eventually.
> I’m using data in the ggplot code. Look again. 

No, I did see that the first time. My point is that because you have done no string formatting on the string you want to write to the text file, you are going to write the literal string "data" to the text file, not the data path.

> The reason it says text_file is because that is a placeholder because I didn’t initially know what to call it.

My point is, you can't call the file you've opened "scatter_plot_R" but then write to "text_file". These are two different variable names. You need to refer to your file with the same reference.

*If you had perhaps run your script beforehand, you might have caught some of these errors.*
Whenever you repeat yourself multiple times, it's a smell you can do better. Examples of these are where you have multiple print statements, or multiple `or` statements, or have a long line of `if...elif...elif` statements. There must be a better way, and there often is.
You're trying to inherit from a module, not from a class. Find the class you want to inherit from and import that instead.
Have you actually tried to run this code? I would be surprised if your code worked. The biggest error I can see is that you are opening the file `scatter_plot_R` but then you are writing to and closing the file `text_file`. And then the second biggest error I can see is that your `data` variable is a filepath but you haven't made it a string. Lastly, you aren't actually using the `data` variable anywhere.
So, I'm very rusty at regex so please take this with a pinch of salt :)

I believe that because backslashes have their own special meaning in regex it wouldn't match the literal pattern. If you want to match the literal string `"\d"`, you'd need to use `r"\\d"` instead.
Yes, it seems none of those require raw string notation. I thought that `"\d"` might require it, but it seems Python 3 will auto-escape that backslash. Still, I'd be cautious around strings with backslashes in.
So, you yourself mentioned that you weren't sure if the four if statements are good. I would agree - when you have multiple if-statements like that, it's a smell that you can do things better. But actually, there is a bigger problem than the code not looking good. The bigger problem is that regardless of how many rules a password fails, your code will only display one error message, which doesn't seem right to me.

I would do a dictionary of some sort. One example could be a dictionary where the keys are your compiled regex and your value is the error message:

    {
        re.compile(r'[a-z]'): 'Your password must contain at least one lower-case letter!',
        re.compile(r'[A-Z]'): 'Your password must contain at least one upper-case letter!',
        re.compile(r'\d'): 'Your password contain at least one digit!',
        re.compile(r'.{8}'): 'Your password must be at least eight characters long!',
    }

You can then iterate through the dictionary, matching the password to each dict key and printing out the dict value if there is a match. Then have additional logic to print out a success if there are no matches.

Also, don't type `if lw.search(pw) != None:`. `if lw.search(pw):` is the same thing and much cleaner.
For my first job, I was asked to show my transcript of my university degree. If you are insinuating that you could just lie about your grades on your resume and nobody would check, that's not true.
But you need to have good high school grades to get into college, which makes high school important.
I before E except after C, but only when the sound rhymes with "bee" - works most of the time, though.
This one is only a little inaccurate. Good grades in school do increase the probability of getting a better job, it's just that there are other factors involved in that too.
Chance Time!
Don't forget adblocking.
Victory was never preordained for Harry Potter. His and Voldemort's prophecy was "neither can live while the other survives", which means either Harry lives and Voldemort dies, or Harry dies and Voldemort lives. 

Also important to note that the prophecy isn't really a thing until book 5. In the early books, Harry knows nothing about the prophecy but still goes off to save people and generally be a badass. I don't know how much different the story would be if it would be Neville instead of Harry.
Not sure if you accidentally missed my point or just intentionally ignored it...

Harry Potter is a character that does stuff and has stuff happen to him, which is why I want to read about him. Neville very really does interesting stuff or has interesting stuff happen to him in comparison; hence a story about Neville would be boring.
Your suggestion doesn't sound good at all. I want to read the story about Harry Potter, not because he's the Chosen One but because he's the guy who actually has interesting stuff happen to him. Who would want to read the story about Neville Longbottom, the guy who doesn't have nearly as much interesting stuff happen to him?
Apps for Windows 10 will not be made for Windows RT. The only apps you'll be able to use are Windows 8.1 apps, which are slowly being abandoned. I would highly recommend you forget getting an RT device and go for something more modern.
Funny - when my father's laptop auto upgraded to the Creator's Update last week, the exact same issue occurred. I wonder what causes it.
I feel like there are problems with the first two reasons. For example, why is fewer characters objectively better? The only objective reason I can think of is file size. And "more consistent" is pretty vague - how is it more consistent?

I'll grant you the third reason, that's a legitimate benefit of tabs. But one could counter that the advantage of spaces is "more consistency" in that indentation will look the same on everybody's screen.
I have had bugs occur in my code because I mixed up whitespace for indentation.
In what way are they "objectively" better? Seems to me like it's personal preference which is better, more than anything else.
There's an important reason to choose either one or the other. Because Python uses whitespace to denote code blocks, it's important to not use both tabs and spaces when you want to create a code block. Mixing up tabs and spaces within code-blocks leads to software bugs in Python 2, and in Python 3 the program will throw an exception.

Extending this idea further, it's good to set a standard for the reasons of sharing code. If you receive a script from someone, what you don't want to have to do is set your editor to tabs or spaces mode before you start to make changes. Within professional software teams, you'll stick to either one or the other depending on the convention within that team.
No one wants to spend enough money on the software we like, so the devs sell the software to other companies instead. Sometimes it works great, other times not so much. See ES File Explorer and QuickPic for examples of the latter.
You can colour the titlebar of most applications in Windows 10 by going to Settings - Personalisation - Colours, choosing a colour and toggling on "Show the accent colour on the following surfaces - Title bars".

Alternatively, if you want to use the colour Chrome intends for the titlebars, go to chrome://flags and enable "Custom-drawn Windows 10 Titlebar".
Sure, but clearing land for agriculture is actually required for us to eat. Farming animals to eat afterwards is not required for us to eat.
That seems like a rather contrived comparison. Sure, killing only one cow is the better option. But that's not the case in real life, where millions of cows are being killed and not just one.
> And why would you post a message towards "iphone users" in an android sub?

For all of that sweet karma they think they'll get from Android fans.
The Plus models have great battery though, especially the iPhone 7 Plus.
Both iPhone and Android have had this sorted for years now. I don't know why Windows phone has such a problem with this.
It's now discontinued in favour of Swiftkey.
It's better to press and hold Home to invoke Now on Tap/Google Assistant, and then press Share. It can be done one-handed, you get to choose if you want to save the picture or not, and it doesn't show any on-screen buttons on the picture.
Well, at least you are consistent, even if I disagree with you overall. I think it's ok to not want to date someone based on their sexual experience, regardless if it's a lack of sexual experience or too much of it. I don't like saying that people can't have dating preferences. I think what is dehumanising is when you shame someone for their sexual experience.
Question - there are a lot of people who are the opposite way. There are those that only want to date people with sexual experience, and don't want anyone who are not sexually experienced. Often, it's those that have no sexual experience at all who only want to date that with sexual experience. Do you think that that is dehumanising too?
I think it's important to make the distinction between having a personal preference and shaming people because they don't meet your personal preference.

In my mind, it's OK to have a personal preference that you yourself don't meet. To borrow your example, its OK to only want to date someone who has less sexual experience even if you yourself have a lot of sexual experience. We have to remember - it often goes in the other direction. People with no experience in sex often only want to date people with a lot of sexual experience. We don't say that there's anything wrong with that choice, so there shouldn't be anything wrong with the first choice.

What's wrong is shaming people who don't meet your criteria. When people start to talk down about those with a lot of sexual experience or those with no sexual experience at all, then that's a bad thing. Sadly, it's still seen a lot.
You aren't the only one who thinks that. We used to have PKZip at work but it's been removed because the powers-that-be think that the Windows Compression Utility is good enough.

To be fair, they are right, it's good enough for 95% of the people that work here. Unfortunately, I fall in the 5%. I need to uncompress password-protected encrypted ZIP files, and the Windows Compression Utility is unable to do that.
It comes with a compression utility, just not 7zip.
I agree religious views aren't a religious belief. You are the one who said "atheists don't have religious views" in your reply to /u/Rikki-Tikki-Tavi-12 above, and you also made the same comment to /u/PiPsteer above too. I'm simply arguing that atheists *do* have religious views, like the argument that two did.

Nowhere did those people say that atheists have religious beliefs - you just assumed that what they said and turned the argument into that.
Not believing in Zeus isn't a religion, but it's a view on religion and religious gods. Your view on religious gods are that you don't believe any God exists, just like some people's view on aliens are that aliens don't exist.
That's due to two reasons:

* You've left your ad fairly wide open in terms of criteria.
* There are *way* more female dommes than male slaves on the internet, so naturally female dommes will get a ton of messages 

Obviously, it's up to you to decide what you want in your ad. But adding as much info as you are comfortable with will help you get more meaningful replies instead of a lot of junk.
Yup, pretty much. IIRC, Microsoft wrote an app in native code without ads and with background playback. Argued that, since Google wrote their app in native code, Microsoft's third-party app should also be written in native code. Google didn't want this, they wanted the app written in HTML5. Microsoft pulled down the app and released it but using a reverse-engineered version of the ad API. Google still didn't want it. Microsoft took down the app because Google forced them too.

Here's the thing - Microsoft may have a "moral" argument that they should be able to write the app in the same language Google wrote theirs, in order to maintain a similar level of quality. However, Google has the legal argument that YouTube is their IP and they can do whatever they want with it. They are under no obligation to allow third-parties to create apps at all. Google's argument will always trump Microsoft's in this case.
I think that the government should define a minimum amount of holiday time. It's easy to say it's voluntary if you have the skills and experience to easily move jobs, or if there are plenty of jobs in your area. But if those things are not the case, and you can't easily find another job that will give you good holiday time, then you are screwed. Your choice is either work every weekday or be homeless. 

Money drives innovation, but not burning out because you had a reasonable amount of time off work drives innovation too.
Open source projects shouldn't be doing that. There is such a thing as copyright. If the creator of a file format did not intend for it to be FOSS, then open source projects shouldn't be trying to reverse engineer them.
If Google wants to see MyTube gone, I can't see Microsoft refusing. The fact that Google doesn't put a proper app on Windows phone is irrelevant. YouTube belongs to Google, so they make the rules regarding third-party usage of YouTube. If they suddenly announced that they wanted all third-party apps to go, while providing no alternative for Windows phone users, they would be well within their rights to do that. 
> Super Mario Galaxy is the best game of its entire console generation

I think Galaxy 2 is better :P
Perhaps you escaped it because you only did upgrades instead of clean installs...? Or maybe it's a Microsoft Account thing, idk...
Doesn't help. We still see the tiles for Candy Crush and so forth.
Really? What about it do you dislike? For me, I prefer it over desktop Skype, and I *vastly* prefer it over UWP Skype.
Meant to say wrote. My bad.
Learning to do basic mental maths IS important. And knowing times tables off by heart is important too. When you are at a shop and you need to buy 6 things that are 70p each, you don't want to be trying to add 70p six times, and you certainly don't want to be pulling out your calculator to figure out how much 6 x 70 is. On the other hand, if you know that 6 x 7 = 42, you immediately know that buying 6 things that are 70p each makes up £4.20.
I disagree. Having exclusively ~~typed~~ wrote cursive for 10+ years, I switched back to print. At first, there was a speed difference but it didn't take that long to get back to pretty much the same speed where I was with print. 
> I would imagine what most people want is a reliable app that is not a memory hog, doesn't crash, uses little battery power...

Apps like Facebook and Snapchat don't fit this category yet have over 1 billion and 500 million Android installs respectively.
"Quintessential."
Author of "Material Incognito Dark Theme" here. Glad you enjoy the theme \^_\^.
The huge holidays. I used to have so much holiday time... now I get 27 days which is including public holidays. It makes you appreciate public holidays that much more.
For my uni, attendance was never tied to grades. The only people who had to *somewhat* worry about it were international students - they were told that the government cared about attendance figures to check that those on student visas were actually studying. But even then, attendance was taken for practical assignments only, never for theory lectures.
I'm siding with the guys on that one. If you invite someone to your place, the expectation is that you provide the food, not ask the guest to cook it for you.
None of that will happen.
You jump ship when you want to. If you feel like Windows phone isn't doing it for you anymore, then switch. If you are happy, then stick.
This article shouldn't really be on Android PIT. The only relation is that the codename for the future Microsoft OS is the same codename as a future Android OS - Andromeda. There is literally no other link between the two.
Then you are shit out of luck, I'm afraid. Go get an iPhone/Android phone or go without Kik.
There is a Windows Phone 8 app for Kik, even though it's broken as hell and missing tons of new features.
Eh, I kinda dispute that. Don't get me wrong, I love Jupyter and its notebooks, and I wrote all the Python code during my undergraduate dissertation using them. But once you start creating multi-module projects and start importing functions and classes from one module into another, Jupyter notebooks start to get in the way and you will want to code using .py text files instead.
It would be nice to have a laptop, sure. However, we have one computer + a screen or projector of some sort, and so one of us logins and that's generally fine.
We don't have work laptops at our workplace, so pen and paper it is. There's nothing to stop me bringing in my own laptop and remoting into my work computer to take notes for meetings, but that's a hassle compared to just taking a pen and paper.
People still wrote stuff. I'm a computer programmer and I still use pen and paper, mostly in meetings where I don't have a computer and I need to take notes.
Not really. There are a few exceptions, such as really shitty paper or card, where you can get fuzzy ink strokes instead of clean ink strokes because of the way the ink seeps in. But for most bog-standard stuff, you should be fine. Just remember that if you write in card, give the ink a little longer to seep in and dry.
I got my Parker fountain pen for about £10 in the UK, which is really nice.
Same thing happened to me. It'd happen if I let the pen roll off the table, which used to happen a lot.
Lots of people predicted that ending and were downvoted for it. I saw it suggested multiple times.
The movie plot occurs on Christmas Eve. Also IIRC, the ending music is Let it Snow.
I read a comment suggesting that the discrepancy may be down to people who think they use tabs but actually use spaces, and those people would tend towards having lower salaries since they are less experienced. It would make sense to me, I fell into the exact same misconception when I started coding.
MS is trying to win over developers because they need them desperately. However, all the open-source goodwill in the world would not have stopped developers abandoning Windows Phone.
These are unrelated things. All of the crap that Steve Ballmer talked about Linux did not stop developers from creating desktop apps for Windows over Linux during the Windows success era. Developers aren't against open source, but when it comes to choosing a platform to develop on, developers look for users and money before open source. This is why iOS has a better app store than Android.
Sure, anything can define your career, but that's missing the point I'm trying to make. High school is the first point in your education where your results actually matter. You can choose to fuck up homework and tests and exams in earlier years and it has little to no effect in the big picture. But fuck up your results in high school and that actually has an effect. At the very least you'll be forced to do extra study to get into college (most likely an extra year) and if you decide not to you'll be restricting your potential careers because you can't get into college.
I don't disagree, but nothing you've said contradicts the fact that high school can also define your career. If you screw up high school, you are locked out of a good many professions cos you can't go to college. That doesn't mean you can't be successful but it does mean there's a chance you might not get to do what you want to do. Hence, high school is the point at which your career really starts to be defined.
High school defines what college you go to.
Even if you take that out of the equation, it's still basically impossible. Another factor I forgot to mention is that you don't even get to see where you are going since the camera doesn't show PUs. But if you take that out of the equation too, it's still prohibitively difficult.
I can't imagine a PU route ever being done as a non-TAS. The amount of accuracy and precision required to traverse PUs coupled with the fact that it takes literally hours to just build up the speed required means that it's practically impossible to pull off.
Wind Waker is native 1080p at 30 FPS.
It was delayed to be ported to PlayStation and Xbox. However, even though it was very controversial at the time, on balance I think it ended up being a good thing. Wii U owners got the Challenge Mode for free for months leading up to the game's release, and they also got a shit-ton of extra levels in the form of old Origins levels that wouldn't have been there if the game hadn't been delayed.
I guess that you'll have a few places using tabs but the majority of places using spaces cos of PEP 8. Tabs vs Spaces still matters though, which is my underlying point.
In London, I have seen a grand total of one Pixel. And that's whilst working in tech where I have seen many Nexus and Oneplus devices
There are pros and cons to having whitespace instead of curly braces. I'm mostly in the pro camp, even though I'm probably biased having only ever programmed in Python. I feel like, since you should be indenting your code *anyway* if you are starting a new code block, the fact that Python forces you to do it is no bad thing. This, together with the removal of curly braces and semicolons, improves code readability.
> You don't become a big youtuber unless you stir the pot a bit from time to time. 

That is what was said. That is what I disagree with. You can be a big YouTuber without having to "stir the pot from time to time".
Another thing I forgot to mention about the debate - some programming languages use whitespace instead of curly braces to indicate a code block. I code in Python where this is the case. And in Python, if you mix tabs and spaces for indentation, it can be a disaster. Doing it in Python 2 will screw up your code from working as intended; doing it in Python 3 will cause your script to fail immediately unless you fix the issue. Hence the need to have a standard that everyone adheres to. In Python, the standard is four spaces, and you use tabs you are doing it wrong.
Different letter width lining isn't really an issue. You should be using a monospace font for programming, where all characters have the same width. Spaces Vs Tabs doesn't really matter that much but using a monospace font is kinda a must if you program.

Also, those who use spaces don't hit the space-bar four times. The tab button is programmed to insert a certain number of spaces instead of the tab character.
If you've tried cleaning the cache or using other browsers or using other devices, and this still occurs, I would send a support email. If that doesn't help, then I would just give up on Outlook and use Gmail instead. You can "Gmailify" your Outlook account, which will let you view your Outlook emails from Gmail. If I'm honest, you should probably do this anyway since Outlook's spam protection has become really weak for me recently.
They could have indeed, but in your comment you imply that apologising is all they needed to do. I dispute that.
If all Hello Games did was apologise for misrepresentation, and they had done nothing else, a lot of people would not be satisfied with that at all. They would be calling the apology "empty".
I disagree. Being controversial may help gain views, but it's in no way a pre-requisite to becoming a big YouTuber. I can think of many successful YouTube channels that aren't controversial at all.
James May says it in the last episode of The Grand Tour Series 1.
That subreddit isn't quite as disturbing as the male versions, but it's still pretty sad to see the amount of hate in there.
Those two phones have 4.6 and 4.7" screens. They are not in the same ballpark as the SE, which has a 4" screen.
You're using doctest to test a very simple function there. When you want to test a more complex function and you have to use mocks and you want to have a significant number of test cases, you want something like pytest or unittest.
That's really weird. PyCharm is definitely heavier than Visual Studio Code, given one is a full IDE and one is basically a text editor. I'd prefer to use PyCharm everywhere, but on my toaster of a computer Visual Studio Code is actually usable and PyCharm isn't.
They only have raise to wake on the 6S and newer. If they had double tap and brought it to earlier devices that would be cool.
It's coming to Chrome on Android - you can enable it in chrome://flags.
It is partly a technical issue, and partly not. 
Second point is relevant as to why it won't happen. You can make demands if you have a popular operating system, like iOS, and get away with them. Windows 10 S doesn't have this luxury.
Firstly, mobile OSs are probably much easier in this regard. Secondly, I doubt Windows 10 S is worth the effort, whereas iOS certainly is.
If all you use is a browser, mail, photos, calendar, and note taking, then why even buy Surface Laptop in the first place? I know people do it, there's a whole bunch of Macbook users that do exactly this, but it just seems to me to be a waste of money. My personal opinion is that something like a Chromebook would be the best tool for the job. It does exactly what you want, is simpler, cheaper, faster and more secure than Windows 10 S.
They own SwiftKey and the WordFlow keyboard was released for iOS before the SwiftKey acquisition. It would be weird to release WordFlow now given that they own SwiftKey which is the most popular third-party keyboard app.
With Microsoft's Windows Store policies, Google would never be allowed to put Chrome on the Windows Store. They'd have to switch from Blink to EdgeHTML, which I can't see happening. That has to be a significant barrier to Google considering Windows Store for apps.
I think that advice is well founded. If you are spending so much money to buy a Surface Laptop, why would you intentionally limit yourself by keeping Windows 10S? And let's not trivialise the "I can't run Chrome" problem - over a billion people use Chrome and it's cross-platform over desktop and mobile in a way that Edge isn't. Giving up Chrome or Firefox means giving up shared history, bookmarks, passwords, etc. But even if you don't care about Chrome, there will be desktop apps that you want to use that aren't on the Windows Store. I guarantee it. And if there genuinely isn't, then you are probably someone who is wasting their money on a Surface Laptop anyway.
Then you either have to find a different theme, or create your own theme programmatically (either by editing your current one or starting from scratch).
iPhone launched without copy paste and, despite the criticism at the time, it did OK :3 The issue was that Windows Phone launched too late, not too early. A couple of years earlier and the world would be different.
People have genuine concerns about 10S. I don't want those bloggers just to put out good news about 10S just because they are "Microsoft-focused". I want to see balanced opinions. For me, learning that Edge is hard-locked to Bing on 10S is enough to make me completely disregard 10S, for that's an asshole move plain and simple.
Yes, these are what Themes can do. Go to the Chrome Web Store and you can browse through the available Themes. Are there any particular colours you are interested in?
Do you need the Professional edition? You could just use the Community edition.
If you make under £21k, that's not much at all. It's not impossible to live on the salary but it'll be hard, for sure. Certainly, your degree would have been a waste of money. 

Most people can't really hide their salary. If you work for a company then the money will be automatically gone from your paycheck just like a tax. You won't see the money at all. The only way you could potentially hide your salary is if you are a contractor or self-employed or working abroad or something like that. But if you are the first two and you are in London, HMRC (the taxman) would likely look closely at you.
I would definitely recommend using a text editor over an IDE in the beginning. It will force you to work out what's wrong with your code rather than have the IDE point it out straight away. Once you are mildly proficient in the language, you can move to an IDE if you so feel like it.
The loan gets wiped if 30 years has gone.

Sure, it's good to save money, nothing wrong with that. It's the actual payment into the loan which is potentially a bad idea.
You take however much you need - £9k per year for the tuition loan plus roughly £6k in "maintenance" loans for help with living costs. Interest always accrues on the loan, from the moment you take it out. However, you only pay it back after uni, once you earn over £21k per year. Minimum payments are 9% of anything you earn over £21k and the loan is wiped after 30 years.

The idea of saving what you can to pay off the loan has the potential to bite you in the ass. If you never earn over £21k, then you've basically wasted your cash. If your earnings are not high enough over £21k to pay off the whole loan by 30 years time (quite a lot of people will fall into this bucket), then, again, you've wasted your cash. You have to have a lot of confidence that you will definitely get a job with enough money to mean that you'll pay the loan off in 30 years with minimum payments, otherwise you will lose money overall. And even if you do earn such an amount, it can be argued that the hit in disposal income right when you aren't earning very much isn't worth it.
Yup, definitely :)
Depends on the loan. This would be bad advice for many people on the UK student loan scheme, for example.
Brushing is also important for gums as well. A lot of plaque buildup is just along the gumline but not necessarily between the teeth. Anyway, I don't doubt what your hygienist says, but I think your gums would be a lot worse of you flossed everyday but never brushed.
Brushing is also key for preventing gum disease too. Plaque will very easily build up and cause gum disease if you don't brush your teeth. Whilst both brushing and flossing are important, I think that brushing is probably more important than flossing simply because you are cleaning a greater area of your teeth.
I don't have an elegant code for this, the best I can do is pack `r, g, b` back into a list, add the two lists element-wise together and then unpack again, like so:

    r, g, b = 0, 0, 0
    test = [5, 4, 3]

    test2 = r, g, b
    r, g, b = [x + y for x, y in zip(test, test2)]
As in you want r, g, and b to be added to the `test` list...? I don't think I quite follow
You want `r = 5`, `g = 4` and `b = 3`, right? Just do this:

     test = [5, 4, 3]
     r, g, b = test
Just a small caveat, since this is Python 2, there are things in here that no longer apply for Python 3. Example being dict.itervalues() - in Python 3, you should just use dict.values().
Make sense. If that's a bother to you and you have to use Windows 10 one day, something like Start10 is a good idea. It's a third party Start Menu that has the option to relegate all the universal applications to a small side menu.
Telemetry and Aero - fine. But why UWP? If you don't like it, don't use it. Pretty much the only UWP you ever have to use is Settings, you can ignore the rest of them.
> G-strings

Lol! Well, can't disagree with you there, G-strings are amazing :P
That's only really the built-in apps though and the Windows Store apps, which, let's face it, almost no-one cares about. This is not a problem if you use the apps that people *actually* care about using (Firefox, Chrome, Office, etc.).
> i don't want to work a tablet on a desktop

I can understand if you didn't want to upgrade from 7 to 8 because of that. But that seems an odd comment for Windows 10. To me, Windows 10 is pretty desktop focused. It only becomes tablet-like if you force it into Tablet Mode, which there is no reason to do if you are only using a desktop.
`self` and `cls` are just naming conventions. However, the first parameter of a class method and the first parameter of an instance method are actually different to each other. The first parameter of a class method is a reference to the class, and the first parameter of an instance method is a reference to the instance. If you start to write code like so:

    class Derp:

        @classmethod
        def class_method(s)
            ...
    
        def instance_method(s)
            ...

then you might confuse yourself into thinking that `s` means the same thing in the above methods, when in fact they don't. This is why it's better to stick to the conventions that 99% of Python programmers use, which is:

    class Derp:

        @classmethod
        def class_method(cls)
            ...
    
        def instance_method(self)
            ...
For me, I think of Cybermen as first half of the series. The end of that two parter where Mickey stays in the parallel worlds feels like a natural halfway point of the series.

The finale was pretty good though, I'll grant you that.
I can't think of any show that has that. The only show I can personally think of that had a boys vs girls competition was Friends and the boys actually won that one.
The Fly episode is probably the worst episode you could have watched. Not because of whether it's good or bad, but because it's simply a poor reflection of the show itself.
The alternate ending frames it differently: that that initial meeting with Robin sets off a precise chain of events that leads him to meeting Tracy, and if he had never met Robin then none of the other things in the chain would have happened either, so he would never have met Tracy. It's always the way that I had thought about the show prior to seeing the ending.
Pretty much everyone who suggested it got attacked by everyone else because the fanbase thought it was such a predictable yet shitty way to end the show. Lo and behold, that's exactly what they did...
Actually, I've liked the past Cybermen episodes, the problem is the stupid BBC who can't help but spoil every decent surprise they have before time >:(
Fear Her, Idiot's Lantern, Love and Monsters; damn, that second half of Series 2 Doctor Who was pretty weak now I come to think about it.
Just keep trying. It's depressing as hell, job hunting, but eventually you'll find something.
Obviously they were looking for someone who worked on the Windows 10 pre-release builds.
So, there are a few major issues to get your code to work - and then a ton of other issues that, whilst are OK, are considered unPythonic. Let's start with the main ones:


---
We have a problem with this loop:

     for i in number:
         if guess[i] == number[i]:
             cows += 1
         if guess[i] != number[i] and guess[i] in number:
             bulls += 1

The problem is that `i` is not the index of `number`, it is the value! The following code below shows this.

     number = "3444"
     for i in number:
         print(i)
    
     # prints out:
     # 3
     # 4
     # 4
     # 4

You want the index of `number` to index into `number` and `guess`. Since we know those variable should always have length 4, we can just use range again:

     for i in range(4):
         if guess[i] == number[i]:
             cows += 1
         if guess[i] != number[i] and guess[i] in number:
             bulls += 1
---
This gets the program to run. I think that you also want the value of `cows` and `bulls` to reset with every turn of the loop (though I am not certain that this is your intention). In this case the beginning of the loop should look like this:

     while guess != number:
         cows = int()
         bulls = int()
         guess = str(input("Input four digit number: "))
         ...

The declaration of `cows` and `bulls` has been moved from outside the loop to inside the loop so that they reset with every turn of the loop.

---

The fixed code looks like this:

     from random import randint
     
     number = str()
     guess = str()
     i = int()
     
     for i in range(0,4):
         number += (str(randint(0,9)))
     
     while guess != number:
         cows = int()
         bulls = int()
         guess = input("Input four digit number: ")
         i = int()
         n = 0
         for i in range(4):
             if guess[i] == number[i]:
                 cows += 1
             if guess[i] != number[i] and guess[i] in number:
                 bulls += 1
         print (cows,"cows, ", bulls,"bulls.")

It's still unPythonic in many different ways, but it works for what you want :) . If you want help making the code more Pythonic, don't hesitate to ask.
Could I see the full code you have in mind?
Can we see the code? That might help us diagnose any issues.
No worries! Once you refactor your code, I'd be happy to have a second look at it. Just PM me once you're done.
The problem I see with your code is that you don't seem to understand how exceptions should be used. The idea of creating four separate exceptions, then raising those exceptions in one place only just to catch them, swallow them and do something else is very pointless. 

Cut out the exception middleman. Instead of this:

    class NoInputErr(Error):
  	  """Raised when the user fails to enter any character in the prompt"""
    	pass
    
    
    try:	
        input = raw_input("\nEnter letter > ")
        if not input:
            raise NoInputErr
    except NoInputErr:
        print "You didn't enter any character"
        continue

just do this:

    input = raw_input("\nEnter letter > ")
    if not input:
        print "You didn't enter any character"
        continue
My advice is to people who only replace phones every 2+ years, not people like you who are outliers. For you, yeah, it doesn't really matter if a phone is bad or not. For most people, it matters a lot more.
And this is why you should only buy a device if you are happy with it at purchase time, and never in anticipation of future updates that will fix/improve the software to a point where you are happy with your purchase. That way, you don't get burned when future updates are not to your expectations or future updates don't appear at all.
This is why you always buy a phone based on what it can do at launch, not based upon future promises of updates fixing/improving software. If a phone doesn't work how you want it to, you should return it and buy something else that does work, not just wait for the next update. That way you don't get burned if software updates that you were expecting to arrive don't arrive or are not up to your expectation.
As a counterpoint, almost never. It's a rare day when I see a lambda function in the codebase I'm working on. However, with that said, it's still important to understand lambda functions and how they work, in case you come across one one day "in the wild".
6snap being pulled was Snapchat's fault. Your comment seems to attribute it to being Microsoft's fault.
I work as a software developer in an investment bank.
I think, if you really want to do machine learning, then probably an MSc will help for that. I don't know much about machine learning and its jobs though, so take that with a pinch of salt. What I do know is that for many other programming jobs, MSc isn't required at all - I got the same job that those with Masters in CS got, but I got it with a BSc in Biochemistry.
No, I think CS is one of the best (if not, the best) degree if you want to go into programming. Employers won't pass over you for it, but they will want to see that you can code, obv. The bigger "stigma" is not having a degree at all; if you don't have *some* sort of degree you'll find it tricky to get a programming job.
For my first programming job, the only experience I had was 3 afternoons of Python learning + several days of writing simple scripts for a Biochemistry final-year undergrad project. That was enough to beat out several Computer Science grads to an entry level position (I was later told by my interviewer that many CS grads couldn't code for shit, which surprised me).
Beans on toast with grated cheese on top (I go for mature cheddar) is heavenly.
With regards to 2, it's almost certain that you will get tested on Python. Like, a technical interview in addition to any competency interviews. The content will vary depending on the position - I applied for an entry level position so I only got asked basic Python questions. I recommend that you learn the common Python interview questions online (create a Fibonacci sequence, fizzbuzz, etc) and that you practice coding on paper (or at the very least coding in a text editor, not an IDE)
I liked using YouTube on Wii U to display videos on a TV. Yeah, I know other things can do that too, but using the Wii U to do it was quite a nice experience.
> In reality, a lot of people who tried Windows phones were impressed with them, and were always longing for more. But then, the media bowed to Google and Apple and preached about "the app gap", as if everyone just needs to be hoarding apps for the sake of having one for everything. 

The media did not "bow down" to Google and Apple by talking about the app gap. Even "pro-Microsoft" websites brought it up all the time. This is because, like it or not, the app gap was a serious shortcoming of Windows Phone. Btw, if you only believe that people criticised the app gap because they wanted to hoard tons of apps onto their devices, you probably also don't understand why the app gap was a big issue and why it contributed to the downfall of Windows Phone.

> Now, we have the EU looking at Google for abusing its search and Android monopolies, and the media has yet again downplayed these as "just the EU hating on those poor good Samaritans at Google who only want to help people have a good experience". Yeah right, as if refusing to make apps for Windows mobile devices is a gesture of healthy competition - you know, love thy neighbor and all that.

Apple and Google don't make apps for Windows Phone because it's not worth the time, effort and money. They aren't the only ones who have come to that conclusion; so many app creators have come to that conclusion. Microsoft is exactly the same in this regard; on the desktop they don't bring their consumer software to Linux for the same reason.
Code looks very good. I have nothing to critique it other than a few pedantic comments, which is up to you if you want to hear them or not :3
It's still Python 2 though. Yes, I know it was added on later, but you still have to deal with multiple string formats in Python 2.
Learning times tables off by heart is important. If you need to know what 3 x 5 is, you don't want to have to manually calculate it by adding 3 + 3 + 3 + 3 + 3 together, and you don't want to have to use a calculator to calculate 3 x 5 either. 

That said, what's more important than times tables is learning *what* multiplication is. It seems like the approach taken by the author is akin to being asked to learn times tables before being asked to learn what multiplication is. What good is knowing that 3 x 5 = 15 if you don't know *why* it equals 15?
The argument about string interpolation could apply to Python 2, imo. I mean, technically Python 3 has 4 ways of generating strings: string concat using + should really be included in addition to % formatting, str.format() and f-strings. However, Python 2 only has one less than that - it misses f-strings but has the others.
Yup, objects have many special methods - `__str__` is just one.
Every object has a string that describes what the object is. This is represented by the object's `__str__()` method. When you pass an object to the `print()` statement, the object's `__str__()` method is called, and the string that is returned is then printed out to the console.

If you haven't yet grasped it, the benefit of using `__str__()` over a user-defined method is that you don't have to call the method first before using print. The below shows this:

Printing a vector using a user-defined method:

    >>> x = Vector([1, 2, 3])
    >>> print x.toString()
    (1,2,3)

Printing a vector using the `__str__()` special method:

    >>> x = Vector([1, 2, 3])
    >>> print x
    (1,2,3)

Can you see the difference? With `__str__()`, you don't call the method, you just print the object directly.
Codewars is very misleading here.

Change `def toString` to `def __str__`. This will make the attempt pass. `__str__` is the string representation of the object, and is shown if you try to print the object out.
This is not how Codewars work. Here, you provide a class and Codewars attempts to "use" the class. You pass if Codewars gets the answers it expects back.
So, there are many reasons why this class will not pass the assignment. I will teach you why it isn't passing the sample test; you should use my advice so that you can make it pass the assignment too.

The test tries to add together two `Vector` instances using the `add()` method and then tries to call the `equals()` on the resulting `Vector` instance.

This isn't working because your implementation of `add()` returns a list instead of a `Vector` instance. The test tries to call `equals()` on the list and fails miserably.

Modify your class as follows:

Your solution:

    def add(self, vec):
        if self.len == vec.len:
            return [x+y for x,y in zip(self.vec, vec.vec)]

My solution

    def add(self, vec):
        if self.len == vec.len:
            return Vector([x+y for x,y in zip(self.vec, vec.vec)])

Notice how we are returning a `Vector` instance instead of a list? However, the test will still fail. 

Currently, `equals()` is checking to see if one `Vector` instance is equal to another. But this will always return False. Because the two `Vector` instances have different allocations in memory, the comparison will always return False. You need to compare the underlying list object. Modify your class as follows:

Your solution:

    def equals(self, vec):
        if self == vec:
            return True
        return False

My solution

    def equals(self, vec):
        if self.vec == vec.vec:
            return True
        return False

Now we are not comparing the `Vector` instances directly, but the underlying list objects. If you click Run Sample Tests, the test will pass. However, clicking Attempt will fail. I hope I have given you enough info to be able to extend your class to pass the Attempt. If you need extra info, do feel free to message me again :)
This is outdated advice. More often than not all you would see is Trump. Case in point, I thought Trump would appear as a prominent controversial comment. When I sorted by controversial, lo and behold, he's there as the top answer e_e
If Cameron had attempted to force his backbenchers to support the Remain campaign, he would have had a guaranteed backbencher rebellion. 100%. Europe has historically been the most contentious issue within the Conservative party. 

If the Lib Dems had tried to force the Tories to stay neutral in the referendum, the Tories would have refused to go into coalition with them. Offering the Lib Dems a referendum on AV was already something the Tories very begrudgingly offered the Lib Dems. Forcing the Tories to stay neutral in the issue? Never would have happened in a million years.
If you had PyCharm installed first, it may be the case that it needs to be configured to use the Anaconda interpreter. But once that is working, yes, all you would need to do is type `import openpyxl`.
Um, no. The referendum happened *as a result* of the 2010 hung parliament. Lib Dems insisted on electoral reform as a part of entering into coalition with the Tories. The Tories, *very begrudgingly*, offered them a referendum on AV. The Tories then campaigned very strongly for No. Please read the article you linked.
> The only way that it could ever stand a chance of passing is through a coalition agreement, and even then most of the largest party will only support it if forced to, and will proactively sabotage efforts to impliment it at every stage.

This describes the AV referendum perfectly.
Search was working fine up until Windows 8 for me. It's only really been Windows 10 where it's just been completely fucked. 
If you install an IDE, it should pick up the Anaconda Python interpreter automatically. 

As for IDEs I would like to use PyCharm. It's my favourite IDE; the only issue being that it's rather heavy and slow for my Intel Atom PC, so I use Visual Studio Code instead.
You can import openpyxl regardless of IDE if you have Continuum installed.

I too have heard that it's harder to get third-party modules to play nicely with each other in Windows. Apparently Anaconda is meant to help with this.
The shtick is that, because he's very effeminate, people mistake him for being gay when he's very much straight.
Yes, that will be the default unless you install something else. You should be able to import openpyxl now.
When I refer to Anaconda Python interpreter, I am just referring to the Python interpreter that gets installed when you install Anaconda. This interpreter is located under the Anaconda directory. If you have only ever installed Anaconda, then you will be using this interpreter by default. If you use the python command in cmd, you will be using this interpreter as there is no other interpreter to use. 

If you already have Python installed and you then install Anaconda, then you will have a choice of two Python interpreters from which to choose from. The only difference that you should care about is that the Python interpreter included with Anaconda will be set-up by default to use the extra packages that come with Anaconda (Jupyter, numpy, scipy, matplotlib, BeautifulSoup, etc) whereas the Python interpreter from python.org may not be set-up by default to do this. 
No, the "Anaconda" Python interpreter works just fine. When installing PyCharm, it will detect that interpreter.
Yes I use the conda command in the Anaconda Prompt, not the CMD prompt. I don't think conda commands work in vanilla CMD, though tbh I haven't tried it out yet.

Yes, I use PyCharm IDE with Anaconda.

openpyxl is included with Anaconda, there are no further steps other than to import the module whenever you want to use it.

I don't actually use 64-bit Python myself; this is because my machine has a 32-bit OS.
All the current replies here are explaining just part of what `super()` does. Yes, `super()` is used to access the base-class implementation of a method, that is correct. However, it's only partly correct and the full explanation introduces concepts such as method resolution order (mro) and C3 superclass linearisation algorithm. I recommend you read [this blog](http://sixty-north.com/blog/series/pythons-super-explained) on the subject. Don't worry, the blog is written to be very accessible.
> Where I get tripped up with them usually are using for and while loops to get certain data in a list or dictionary. 

There are very few reasons to use a `while` loop when iterating over a list or dict. 99 times out of 100, you should use the `for` loop to do this. `while` loops are best left for implementing `while True` loops. 

To get all the keys in a dictionary, iterate over `dict` or `dict.keys()`. To get all the values, iterate over `dict.values()`. To get key-value pairs as tuples, iterate over `dict.items()`.

> For example, iterating through a List and getting the index of every value without using the enumerate function. 

Why do you want to do this? `for i in range(len(list))` would achieve this but there's no reason to use this over `for index, element in enumerate(list)`. 

> Also I understand the basics of not being able add lists to ints, and things like that but when I'm coding I don't realize that I'm doing those basic errors.

When you start out new, everyone makes these errors. I can't tell you how many times I tried to concatenate a `str` and an `int`. Now, I never make this error. To stop making these kinds of errors, your best bet is just to keep coding until you don't make them any more. Of course, you need to know *why* the error is arising, but it seems that you already know this.
You shouldn't launch CMD, you should launch Anaconda Prompt. From here, conda commands should work.
It looks like it could work just fine in 2.7. Try literally just running the exact same code in Python 2.7 and see how that goes for you. 
So, I'm not an expert here, but my guess is that it's something to do with environment variables...? Type "environment" into Start and click "Edit the system environment variables". Click "Environment variables", then under "User variables for x", click Path and then click Edit. You should have all the Anaconda-paths at the top. 
I use Anaconda. You get all the main STEM-related python packages built into Anaconda, and keeping all of these updated is two commands (conda update conda ; conda update anaconda). 

As for your other question, it's probably very unlikely that you need a package not in the 64 bit version. I would just go for 64 bit.
Everything /u/JohnnyJordaan said is very correct. Since this is Father's Day and you don't have much time to turn this script around before it ends, I thought I would rewrite it much simpler for you :)

     # Here we place all statements into one list. This is more Pythonic than having each element in its own function. 
     # Placing them in a list allows us to iterate over the list, as seen below.
     polls = ["Your Q1 polls indicted a strong start to the week. 67% of those surveyed found that helping one move back in is viewed as a good act.",
              "However, your Q2 polls show that a controversial 33% of those surveyed found the lack of jiblets disturbing.",
              "Your Q2 polls did, however, rise by 34% in the last 12 hours, as the majority found going to a movie to be a good use of one's leisure.",
              "Your Q3 polls, however, are projected to start at 0%, as 100% of those surveyed found Father's Day to be unproductive and self-centered. Experts recommend bribery and shameless compliments to bring up one's polls.",
             ]


     def prompt():
         """ This function expects either Enter or q as valid input. 
         If another input is given, the user is queried continuously until a valid input is given."""
         while True:
             input_prompt = input()
             if input_prompt == "":             
                 return True
             elif input_prompt == "q":
                 return False
             else:
                 print("Can't even follow basic directions? This is not looking good for your polls! Try again.")

     # Menu       
     print("Your polls for the week, below. Press enter to continue; type q to quit.")     
     
     # We iterate over the list, prompting each time before printing. If the user types q, nothing more is printed.  
     for poll in polls:
         prompt_call = prompt()
         if not prompt_call:
             break
         print(poll) 
           

Don't hesitate to ask if there are any questions!
    
When Google Now is the left pane of the launcher, it's already loaded. With the swipe up gesture, Google Now has to load first before it can show anything. The loading only takes a second or two, but it's not nearly as seamless as having it already loaded. Plus, this is just an anecdotal thing, but I personally found myself using Google Now considerably less with the swipe up gesture. Out of sight, out of mind.
Putting aside the fact that this scenario is very unlikely to happen, this isn't even the definition of Embrace Extend Extinguish. Google the term so that you understand what it means before trying to shoehorn it into your paranoid beliefs. [From Wikipedia](https://en.m.wikipedia.org/wiki/Embrace%2C_extend_and_extinguish?wprov=sfla1):

> "Embrace, extend, and extinguish" ... was used internally by Microsoft to describe its strategy for entering product categories involving widely used standards, extending those standards with proprietary capabilities, and then using those differences to disadvantage its competitors.

Literally none of that is happening here.
It also shows idiocy. Why would you purchase WinRAR when you could just download 7-zip for free?
I mean, of course it isn't, but the original criteria was just school pupils. If we are widening that criteria then we have to include others, like Dumbledore himself for instance, possibly Quirrell too.
"one student murder". Barty Crouch wasn't a student.
It's tricky to make a victory speech when you don't have the victory you want.
I think it would be paranoid and incorrect, quite honestly. The Tories and Theresa May called this election to get a significantly increased majority. This result was absolutely not what they were after when they called this election.
`self` is just a parameter, same like any other. Try not to think of it as anything too special! self is just a reference to the instance object, and since we only call `f()` when it's bound to my class, `self` must be an instance of nyClass. Be aware that when you call `c.f()`, this is actually syntactic sugar for `myClass.f(self=c)`.
Looks good - I have just the minor of nitpicks. With regards to `print(str(num))` at the end of method 2, this is completely equivalent to just having `print(num)`. There is literally no difference.

When you pass an object to `str()`, you call the `__str__()` special method on that object to get a string representation of that object. In the case of an object of type `int`, `__str__()` just returns the integer but as a string. For more complex object types, you'll get a different string.

When you pass an object to `print`, this automatically calls `__str__()` on that object to get its string representation, and then prints that out. This is the fundamentals of how `print` works. I hope you can see now why `print(str())` is redundant.
The actual way to do this is `if instance(n, (float, int))`, although it's best to avoid type-checking at all if possible.
The save button is your friend here :3
I'm thinking more about domestic gun violence. The number of gun homicides is way higher in the US than in any other country with decent gun control. It's also way higher than the number of Americans killed by terrorists, and it's way higher than the number of people deliberately run over by cars. If the argument is "protecting the US people", then gun control is without a doubt the highest priority. Not removing health insurance from millions of Americans should be way up there as well.
I find the arguments against trying to protect US citizens kinda funny given how many people will die from guns due to lack of adequate gun control and how many people will die from not being able to afford health insurance if the Republican Health Bill gets passed. 
Did you instantiate your class first? You have to instantiate it to get an instance object before you can call `add_friend`. Something like this:

     from module_name import Profile
     
     profile1 = Profile()
     profile1.add_friend(f_email)

On a side note, why do you have so many getters and setters in your class? This is not Java! You shouldn't be having getters and setters in Python code, you should simply be accessing attributes directly. 

Instead of

     class Profile:
         def __init__(self, name, ...)
             self.__given_name = given_name

         def set_given_name(self, name):
             self.__given_name = name
       
         def get_given_name(self):
             return self.__given_name

         ...

     profile1 = Profile()
     profile1.set_given_name("Adam")

do:

     class Profile:
         def __init__(self, name, ...)
             self.given_name = given_name

         ...

     profile1 = Profile()
     profile1.given_name = "Adam"

The second way is far cleaner and means you don't litter your classes with getters and setters.

"Donny" is pretty much saying not all Muslims though. He's not consistent with his actions. On Donny's travel ban, why wasn't Saudi Arabia or Pakistan on the list? Have you seen the way he sucked up to Saudi Arabia in the last few weeks? His travel ban conveniently didn't include Saudi Arabia because then he would piss off the people who give oil to the US and he would lose out on the billions of dollars of weapons he can sell to them. 

Also, your trolley problem would apply to a lot of things that Americans don't want to do. You're making it about Muslim immigration. What if we make it about gun control instead? Why doesn't he or any Republicans "switch the tracks" for that?
To scroll up, yes. To scroll down, no.
So, the first and second options are pretty much exactly the same thing, though the first option is more Pythonic and more commonly seen.

It's important to note that the second option isn't really equivalent to declaring types in Java or C#. I believe that when you declare a variable type in those languages, you can't change it. If you say `int i` or `string s` in Java/C#, then `i` and `s` can only ever be `int` and `string` respectively. You CANNOT write the following:

     int s = 1;
     string s = "2";

In Python, however, this is not how types work with variables. Having the following is perfectly fine:

     s = 1
     s = "2"
     s = int(3)
     s = str(4)
     print(s)    # "4"

This is the difference between static-typed languages (Java/C#) and dynamically-typed languages (Python).
Method 2 is safer.

With method 1, you have to explicitly remember to write `f.close()` otherwise the file doesn't get closed. Also, if your program raises an exception and comes to a screeching halt between opening and closing the file, your file will not get closed, which is not what you want.

With method 2, you don't write `f.close()` so there is nothing to forget. The with-statement automatically closes the file for you at the end of the indented code block. Furthermore, if an exception occurs within the with-statement's code block, the file is still closed. This is due to the way that with-statements work. To really understand what the with-statement does, you have to understand what a context manager is, so I highly recommend Googling "Python context managers" and reading up on the topic.
No problem!

One other thing I've noticed - you seem to comment your functions with `#` comments. The proper way to document a function is to use a docstring, which is a triple quoted string `"""like this"""`.

So, instead of documenting the function like this: 

     # Pick a random food from the Python.txt file and print it out.
     def requestFood():
         line = random.choice(open('Python.txt').readlines())
         print(line)

document it like this instead:

     def requestFood():
         """Pick a random food from the Python.txt file and print it out."""
         line = random.choice(open('Python.txt').readlines())
         print(line)

Use docstrings when documenting functions and classes. Everywhere else, use `#` comments.

Any other questions, feel free to message me :)
It's the mode that you are opening the file in in your `registerFood()` function. Opening a file in `w` mode will overwrite the file if it already exists, and starts afresh. Open the file in `a` mode instead (`a` for append). 

As an aside, I notice that you are opening your files but not closing them. This may also be causing issues as well. Make sure to close an open file everytime you are done with it. There are two ways to do this.

Method 1:

     f = open("Python.txt", "r") 
     # do stuff here
     f.close()

Method 2 (preferred):

     with open("Python.txt", "r") as f:
         # do stuff here - 
         # file automatically closes when you leave the code block

Have to disagree there. iOS scrolling gets progressively faster but nowhere near the speed of Android. It's for this reason that I can't stand iOS scrolling. On Android, I can go from top to bottom of a medium-sized page in one quick flick of my thumb. The same action on iOS will take many, many swipes to achieve.
Python 3 is easy to learn if you know Python 2, it's just knowing the small details around what's changed - 95% of the stuff is the same. Definitely use Python 3, there's no point limiting yourself to an older language version.
The short explanation of what `super()` does is that it calls the base-class implementation of a method. So, here, because `addition` is the base-class of `addition2`, `super().__init__` within the `addition2` class calls `addition.__init__()`.

In reality, `super()` is a little more complex that that, and I highly recommend you read [this blog article](http://sixty-north.com/blog/series/pythons-super-explained) to understand its inner workings.
No, disagree. Omnibar is awesome. I type both addresses and Google search terms into the Chrome omnibar (as you are supposed to do). It works fantastically - 99.9% of the time, Chrome knows exactly which is which.
Sometimes on Edge it isn't there on the homepage because the homepage has a search bar itself.
There is a power saving mode in PyCharm, have you​ tried that out?
If you Google PEP 8 you will find it.
Those kinds of errors decrease in frequency as you code more often. Also, many good IDEs will highlight those kinds of errors for you. Heck, many shitty IDEs will do that for you too.
You should have a cloud backup, IMO.
Dropbox is good, but won't save you from shit like CryptoLocker (unless you really want to rely on Dropbox's versioning).
School/university documents? Family photos? Personal documents?
It's /r/learnpython .
Your append function is not under the for loop. This is why your code is failing. That said, there are other small things as well that you should know.

---

Firstly, whenever you open a file, you must always close it when done. Either do this:

     f = open(my_file)
     # your code
     f.close()

or this:

     with open(my_file) as f:
         # your code in this code block

---

Also, don't use `list` as a variable name in Python as it's bad practice to use the names of built-ins as variables. Once you assign list as a reference to something (e.g. `list = "hello"`), you mask the built-in list function, so your command `lst = list()` would no longer work.
Yup, you said it yourself, you are in the wrong console. That Python Console is completely independent and only there if you just want to do some random REPL'ing before​ you continue onwards.

What you want is, when you hit your breakpoint, press Debug in the lower left corner and then there should be a Console tab within Debug.
Right, yeah, I know that already but I'm pretty sure OP did not. I didn't want to confuse my question by bringing in `object.__init__` when I'm almost certain that OP doesn't​ know about that and is thinking about something else.
I'm not referring to the bot's comment, I am referring to the comment made afterwards that the bot's comment was "outdated advice". 
I guess that the outdated comment is not referring to string concatenation, but instead to [Python 3.6's f-strings](https://www.python.org/dev/peps/pep-0498/). 
So, you can totally have a function like that. You can totally ignore `__init__` and create your own initialiser, like so.

     class MyClass1:
         def my_initialiser(self, attribute1, attribute2):
             self.name = attribute1
             self.age = attribute2

The only difference is that you will have to create your object and then call the initialiser function explicitly. This requires two separate lines of code. 

     MyObject = MyClass1()
     MyObject.my_initialiser(attribute1="Joe", attribute2=18)

The reason we use `__init__`is because it allows us to create and initialise our object at the same time. Consider the following class.


     class MyClass2:
         def __init__(self, attribute1, attribute2):
             self.name = attribute1
             self.age = attribute2

It's the same as the previous class, it just uses `__init__` instead of `my_initialiser`. But we can now create and initialise our object with one line of code only:

     MyObject = MyClass2(attribute1="Joe", attribute2=18)

Does that help explain why we use `__init__`?
I don't understand what makes you think `__init__()` is predefined. Until I understand why you think that that is the case, I can't really answer question 1.
> Even on small phones like the original iPhone that's too far for the average hand.

I have to disagree with this - I owned a 3.8" screen phone and had NO problem reaching all four corners. And the original iPhone is 3.5". You really have to have small hands if you can't reach the top left corner on the original iPhone.
I'm definitely on the side of testing. I feel like even if you do a pet project, tests are useful. There's been so many times where I added features to my pet project and my tests broke in ways I simply didn't foresee. It's the same with code that I write professionally. Tests have saved my ass countless times. Yup, you will​ have to teach your gf how to actually write code properly though. Functions and classes, not big monolithic hairballs of code :P

Since you asked, I've been working in software development for an investment bank for 5 months now. I'm a uni grad.
I think those apps will come soon, but I won't be surprised if they don't. And at any rate, they were not a priority for Nintendo.
But many people do find it funny. Millions of people tune in because they find it funny. The show has won awards because people like the show. If you don't like the show, that's fine, but to call it an "absolute failure" is to ignore its popularity.
Can't see that happening. The Switch seems to have gone in the opposite direction here, it is a gaming console and a gaming console only. No web browser, no entertainment apps, just games. It would be a U-turn at this point to shoehorn in phone capabilities. 

It would also be a terrible decision. Just putting in basic phone capabilities is stupid. A Switch mini would never be as small or powerful as a dedicated smartphone. Everyone will still carry their smartphones around so adding cellular capabilities is adding cost for no benefit.
I'm not the person you replied to, but I thought I'd tackle one of your questions, inheriting from object. 

In Python 2, you have two different types of classes. Old-style classes and new-style classes. New-style classes have more functionality than old-style classes. You use a new-style class by explicitly inheriting from object. If you don't inherit from object, then you are using an old-style class. 

In Python 3, old-style classes are gone. Only new-style classes remain. If you don't specify any inheritance when defining a class, it will automatically inherit from object. The base class of all classes in Python 3 is object, and there is never any need to explicitly inherit from object in Python 3 as this is done implicitly. 

In practice, never explicitly inherit from object in Python 3. This is not because of any technical reasons, but more because people reading your code will assume that you are unaware of how classes work in Python 3.
Google "Look Before You Leap" and "It's Easier to Ask for Forgiveness than Permission". Your method 1 is the former, and your method 2 is the latter. The Pythonic way is definitely method 2 - always prefer to do that.
Yup, it's not cheap haha! But I get it as part of a perk from the company I'm contracted out from, and when my contract runs out I would have no hesitation in footing the bill myself. The quality of the videos are worth it for me.

EDIT: Austin Bingham and Dr Robert Smallshire have books that are significantly cheaper. Do a search for "The Python Apprentice" and "The Python Journeyman" online.
This is part of Material Design which was official released around half a year ago now.
Whether you are working on a huge project for a company or just a pet project for yourself, tests are important. I can't tell you how many times my pet project unit tests have caught bugs or errors when I introduce new code. So yeah, if you do know how to write tests, then you should write some ASAP, and if you don't then you should check out Emily Bache's course.
I had planned to "go off the beaten Python path" and do the Design Patterns videos, but I wasn't sure how good they were. I'm glad to hear they are good videos. I am just coming to the end of Beyond the Basics myself - I will likely do Emily Bache's Python Testing video first and then go to Design Patterns.
I look forward to seeing those, I'm sure they'll be great :) 
Are you Bo Milanovich? I actually watched your video as it came out. I noticed that it replaced Scott Allen's video as the first video in the Python path. I think that your video is a huge improvement over that one, so well done! You have a real passion for what you are teaching that doesn't come out of all the Pluralsight presenters.

I think your video is excellent for a viewer that doesn't know whether or not they want to learn Python and wants to get a taste for what it's like. However, for the person that knows they want to learn Python (or has to learn Python) then Python Fundamentals is a better starting point as it's more comprehensive whilst covering everything that Python Getting Started has.
My recommendations are videos, I hope that's ok :3 I'm a big fan of Python Fundamentals and Python Beyond the Basics videos on Pluralsight. The series is created by Austin Bingham and Robert Smallshire from Sixty North. They explain all the features of Python *very* well, they cover quite a lot of what Python can do, and they show examples of how everything can be used.
Have you set Anaconda for the Python interpreter in PyCharm preferences? I would have thought that would be enough.
Why not Java to Python 3 directly?
My suggestions to you:

Instead of having 4 stats that are all set to exact value at the beginning, consider using `base = 10` instead. 

You can then have 

    high_stat = base + randint(2,5)
    mid_stat = base + randint(-2,2)
    low_stat = base + randint(-5,-2)

And then you can use dictionaries to hold the stats of the different characters.

    knight = {
        "strength": high_stat,
        "speed": mid_stat,
        "magic": low_stat,
    }

    princess = {
        "strength": low_stat,
        "speed": high_stat,
        "magic": mid_stat,
    }

    wizard = {
        "strength": mid_stat,
        "speed": high_stat,
        "magic": low_stat,
    }

Now there is less repetition in your code! If you want to change one of the randints, you only have to change in one place, not three. It's also communicates to the reader much clearer that the only differences between the three characters are the order of the stats, and it communicates clearly the strengths and weaknesses of each character.

EDIT: Also, be aware that in Python 2, print is a statement, not a function. You don't put parentheses around things that you want to print in Python 2, unless your print command spans multiple lines
My advice? If you are able to, move somewhere that has good public transport so that you don't need a car to move around. Easier said than done, obviously, but if it's within your grasp I would recommend it.
Why in the US? Any reasons?
Everybody who goes for internships has crappy resumes - it's why they are looking for internships. But you can do things to make your resume less crappy. The first one is already out of your control by this point, unfortunately - it's the university that you are in. Pursuing a degree in a top 10 global university will set you apart from the pack that are in lesser known unis. The rest of it is being able to show enthusiasm for the internship in hand. If you are going for programming, have you started on any pet projects outside of university? If you are interested in working in a biochemical wet lab, have you been doing outside reading of books and journals beforehand? Have you managed to get any lab experience at your university? If you want to find someone in journalism, have you written articles for your university newspaper, or have you started your own personal blog? These things will instantly set you ahead of the many, many students who don't have these things.
I'm a Biochemistry graduate with no internship experience who landed a software development role with an investment bank within a month of graduating. So you might not necessarily get screwed - don't be immediately disheartened. You might find it hard to get interviews, but you want to make sure that once you get an interview, you nail it. For example, interviews will likely ask you to write code with pen and paper, so it might be a good idea to start honing that particular skill early, because it's *not* easy at all, especially if you've been relying on an IDE your whole life.
Our uni had that too, it was just the department messaging everyone was in addition to that. But with all of those things, students will still be lazy, right? I never did any internships despite everything that happened.
I got my license at age 22. Many of my friends got it around age 20. When you live in a city with extensive public transport, a driving license is not a necessity at all.
I'm not saying that you lied about it, it's just that for me the experience was kinda different and I thought that my experience was the norm rather than the exception. For me, I was constantly reminded about volunteer/internships/jobs/etc. We had a dedicated person in our department who would specifically send us emails about this.
This advice depends HUGELY on how good public transport in your area is. In the US this is likely solid advice, but less so in London/Paris/Tokyo etc.
Really? No one told you this? I find it difficult to believe that you went through uni without anyone mentioning how important internships/volunteering/etc are.
Asking for internship experience for an entry position is legit. Asking for two years experience is just stupid. Internships != two years of experience.
Internships make it way more likely for you to get a graduate-level job. That doesn't mean that it's *impossible* to get a job without them. I also got a grad job without an internship, but I only got away with it because a) my degree was from one of the best unis worldwide with very high employment rates, and b) I got into a scheme with a recruitment company that specifically contracts out grads to financial companies. Without those two things, I most likely would have been screwed too.
>A lot of people with CS degrees don't really know how to code, which is baffling to me.

That one is funny, isn't it? When I had my first job, the guy who did my technical interview complained that too many CS graduates just don't know how to code. I graduated with a Biochemistry degree yet beat out a number of CS graduates on the technical interview. His theory is that too many CS students use IDEs instead of text editors, and that the students become so reliant on it that they suddenly find it very difficult when they are just given a pen and paper and are told to code. I doubt that his theory is the full reason why some CS grads suck at coding, but I think it's likely a contributing factor.
http://i.imgur.com/i4T0z70.png
Sometimes it was arbitrary, sometimes it wasn't. For example, games like Wii Sports Club could never have been compatible with anything other than the Wii Remote. Games like Wii Party U or Mario Party 10 that used Wii Remote motion controls would have had to be modified to remove those elements if it wanted to have Wii U Pro Controller support.
I'm kinda happy that they didn't. The controller situation with the Wii U was a complete mess, in my opinion, and making a clean break from that was necessary. Now, every single game is compatible with JoyCons, so if you buy a pair of JoyCons you know that you can play every single and multiplayer game without exception.
This isn't an /r/android thing, it's a "every single subreddit that exists" thing. 
As someone who actually used Vista till 2012, I can say that this was nothing like my experience of it. A lot of things about this video are either incorrect or misleading, which I'm OK with because it's meant to be an "entertaining" video more than anything else, but if you are going to claim that this is what using Vista was like then I'm going to have to disagree with that.
And I'm saying that it didn't fail for that reason. Even if you only look at updates, they have nothing to do with the failure of Windows phone.
Yes because that isn't a Chrome theme per se. It's the default skin. The Chrome devs can modify all sort of code that we Chrome theme devs can't, which is why you don't see that line.
Yeah, every theme has that white line. It's a Chrome theme limitation - only the Chrome devs can do anything about that.

I was just answering your question about Incognito Mode design in normal mode
I have a theme that emulates Incognito mode in normal mode: [Material Incognito Dark Theme](https://chrome.google.com/webstore/detail/material-incognito-dark-t/ahifcnpnjgbadkjdhagpfjfkmlapfoel?hl=en-GB).
> Why talk about things you don't remotely understand?

You must be new to reddit.
Pluralsight is the way to go. There are same excellent "Python Fundamental" courses on there - the ones I like are from a group called Sixty North and they really explain the concepts well, assuming nothing.
No, Windows Phone didn't fail for that reason either. Normal people don't give a shit about updates. To them it doesn't matter, it's more an annoyance if anything.

Windows Phone failed because of lack of apps. Simple.
As someone who went movies to book, it's definitely the former for me. I liked the Hobbit, as a book, but LOTR the trilogy definitely dragged on.
You don't *need* to. You can do exactly what Never10 does without needing to install it at all. Never10 just automates and simplifies the process 
I don't see why you need those features though. Microsoft's way of disabling Windows 10 upgrade is very very unlikely to fail and you don't need multiple ways of achieving the same thing. Never10 achieves what you want with minimal resources.
>"I will not settle for someone who is shallow"

>Only looking for white people
You don't even have to go through the assistive technologies link. You can install it anyway you want so long as you are upgrading from 7 or 8, and MS will count it. MS are looking the other way when it comes to these upgrades 
That's probably because your computer was in an update state that was before the upgrade expired. If there was an update to remove GWX, your computer may not have received it yet. 

My advice? Install Never10 which turns off the Windows 10 upgrade the "Microsoft recommended way". Then install all the updates.
There are legit reasons why you might not want to. If you are running older hardware, then the driver support may not be there making the experience an overall worse one. Then there is app support - it is possible that you are using an app not supported for Windows 10. 
The free Windows 10 upgrade ended half a year ago. Not excusing MS's aggressive upgrade behaviour one bit, but killing Win 7 automatic updates is no longer necessary and an overall detriment to your security.
I agree it would be amazing for Chelsea. I don't agree that Grant wasn't a permanent option though, I think that's a bit of revisionist history right there. Both Grant and Ancelotti were fired in seasons where they came second. The reason - they didn't win any silverware that season. That is the price of failure for Abramovich. Don't say I agree with it, just that that's how it goes.
Abramovich doesn't really differentiate between the two, though, does he? If Conte ended next year as Premier League and Champion's League runners-up, there's a good chance he could get sacked. It happened to Avram Grant, it could happen to Conte.
Very well, my mistake, for some reason I thought it was his first season. 
Either that or it all goes to pot in the second season, like Ancelotti ~~and Mourinho second time around.~~
If you don't like it by Episode 7, you'll never like the show. And I agree, I think TGT suffers from being overly scripted.
For them, it isn't UWP and it's not touch-friendly, which makes it broken.
It reminds me of how Nintendo name their portable line more​ than anything else. They went from "Nintendo DS" to "New Nintendo 3DS XL".
Making pretty looking pictures/videos is far easier than implementing a full design language in computer code. 
Nope, converted to Store apps. The different is subtle but important. Desktop apps still need to be rewritten to become a true UWP app, an app that can potentially run on any Windows 10 device.
I think that's true for certain "rules" on this thread but that's not true for all of it. There is definitely things which aren't as subjective. Examples are having too long a CV, or having inconsistent font sizes, or having too generic a CV. Fixing these things will, at worse, do no harm to your chances, but more likely will give you more of a chance of standing out.
Internships and entry-level positions, I guess. And yes, I know that many entry-level positions also ask for experience - it's annoying as hell to see that. For me, I got a job through a recruitment company that does a "graduate scheme" with financial companies, where the financial company outsource the hiring and training of graduates to the recruitment company. That gave me a route into software development in investment banking.
Microsoft is, but Hotmail isn't. Microsoft has deprecated the Hotmail brand for almost 4 years now. There's no reason not to get an Outlook email address, MS will let you create an Outlook alias and have it link straight to your Hotmail inbox. 
That's the problem with the animation, methinks. The UWP ones "slide" into place whilst the desktop ones just appear.
I've never really thought this, though I know that others have. When I transitioned from 2003 to 2007, I immediately thought that the Ribbon delivered a better UI/UX than the menu/toolbar hell that preceded it. I was sincerely glad to see the back of that.
Not the guy you replied to, but for me the big one was the user interface. I just can't get over the old menu interface in LibreOffice. The Ribbon is just *so* much nicer IMO and using LibreOffice feels like I've been transported back 10 years in UI design. 
Please, be real. How many adblockers actually do what you suggest? If people actually did what you suggest, the internet would survive. But the problem is that they DON'T. At least, a huge majority do not. Those that do do it selectively. They may support a Twitch streamer here or a Youtube supporter there but the rest of the sites they visit get nothing. The reason is money. People don't want to pay for every site and content creator that they view online - that shit gets expensive FAST. Ads are the only way around that - no-one has come up with anything better. 
No-one will. If MS killed off Windows phone, it will eventually reach Windows Mobile/Kin/Zune-levels of dead. 
Yeah, your only option is to use something like Stardock's WindowsBlinds, methinks. I considered developing WindowsBlinds software for the themes that I have in the Web Store. The thing is that it's $10 for me to develop the solution, and then $10 afterwards for anyone who wants to install it. Almost no-one has asked for it or has requested it so I haven't bothered wasting my money on it.
I don't want to use uBlock Origin because I don't want to block all ads. I'd happily block those scam ads but I want to let legit ads through for all sites. If the proposed Chrome ad blocker turns up, I'll probably end up using that.
Chrome themes can't change the address bar. Changing the address bar depends on what OS you are on and how much you want to fiddle around with OS theming or not.
TIL pointing out why an analogy is shitty is nitpicking. Well then, let me nitpick some more.

In the case of a lock, a crappy lock is objectively worse than a good one.

In the case of courtship, a woman that takes an active role in looking for relationships or sex is NOT objectively worse than a woman that takes a passive role. 

By stating the analogy, you are arguing the opposite. You are effectively stating that women that take a more active role in seeking out relationships or sex are worse than those that don't, much like a shitty lock is worse than a good one, and you are shaming those women for doing this.

That to me is why the analogy is shitty.
The point is that both analogies are terribly shitty, not that one is better than the other. Locks keep someone/something in one place (either to protect it or to stop it from being taken or from escaping). Vaginas do not do that. Comparing the two is asinine.
Just because women have it easier when it comes to sex, doesn't mean that it's ok to shame them for taking advantage of that.
Reducing everything to just biology is flawed. It ignores that women can demand men to use condoms and can use birth control themselves, which mostly eliminates the problem of becoming pregnant from sex. 

Also, with this argument, men who choose to use condoms (or who ask women to have birth control) are also failing at their core biological imperatives. Yet men are almost never shamed for such actions.
I liked the GamePad controls for Off-TV play. But I think if you are playing on the TV, then you want to keep your eyes on the TV as much as you can, not shift from one screen to the other, and Wiimote + Nunchuck is best for that (though not ideal since you are forced to use the GamePad for certain stuff anyway).
The average consumer is never going to do that. This phone is going to be dead on arrival if this is the required step.
Whilst I liked the GamePad idea, I hate that it was forced on you if you also wanted to do Wiimote + Nunchuck. It made the control scheme more annoying than it should have been.
The sleep in our eyes would be left alone instead of cleaned every night. It would accumulate and aggregate into giant humanoid sleep bogey monsters that will attack us and take over the world.
I don't see how you can use it properly when you have to hold the JoyCon upside down to use it, but that's just me.
Most people don't even know what Cemu is, let alone are going to use it. It's pretty much irrelevant in this discussion of who will buy/play MK8 Deluxe.

Furthermore, there are benefits of Mario Kart 8 Deluxe that you won't get from Cemu which can only play the Wii U version of the game. A proper battle mode is one of the benefits, but the big one IMO is portability. I saw two guy on my bus yesterday playing MK8 Deluxe with two JoyCon remotes. If I decide to purchase it myself, I can bring it into work and do local multiplayer with my other Switch-owning coworkers. This is possible because of the portability that Switch gives you. Most people on PC have desktops that they *can't* just bring wherever you want, and before someone says *gaming laptop*, those things are pretty heavy for laptops and require you to bring around extra peripherals for multiplayer. They can't compare to Switch in the portability argument.
The IR is on the bottom of the right JoyCon. You can't actually use the JoyCon properly when using the IR. And you can't use it with the TV anyway as there is no sensor bar.
Yup, it was his pride that fucked him over. He could have just swallowed his pride and take the money from Gretchen and Elliot to pay for his cancer treatment, but he couldn't deal with it given everything that had happened in the past. 

And yep, people hate Skylar for constantly asking where Walt is, as if someone who disappears for hours with no explanation is somehow an acceptable thing to do.
The aiming in Skyward Sword used the IR to calibrate the Wii Remote, at the beginning of the game. It's only after the initial calibration that the Wii Remote uses gyro. And even then, while the pointing is OK it isn't nearly as nice as just regular IR. 

I can't speak to how World of Goo works or how good its solution is.
Only the right Joycon has IR and you can't use it for pointing at the screen because there is no Sensor Bar.
It's crazy how many people hate her because of the crap she did whilst TOTALLY ignoring how Walt was orders of magnitudes worse in this regard. Yes, Skyler smoked whilst pregnant and cheated on Walt. Walt was a meth drug dealer who killed numerous people, both indirectly and directly, and ruined the lives of countless others. 
Firstly, it's not a laugh track but a live audience. This has to be repeated any time BBT is brought up on reddit.

Secondly, removing the laughter from the show proves NOTHING. The actors deliberately fit their lines around the audience's laughter, of course if you remove the laughter then you will just get huge awkward pauses. This is literally the case for any show that uses a live audience - you will make any such show look bad if you hack out the laughter.

Tbh though, those things aren't nearly as bad as the "nerd blackface" thing. When someone uses that phrase unironically, it really tells a lot about them. A sitcom can stereotype women, black people, Jews, Muslims, whatever and people here don't give a shit. However, the moment a sitcom stereotypes a nerd, suddenly a line is crossed. 
Browser Mode actually makes sense with the cart, IMO. Don't know why they couldn't just have the Bowser Mode with the cart and then "normal mode" be the classic Mario Party where you play individually.
Eh, no Wii Remote support makes me inclined to disagree. IMO, the best TV control system for Pikmin was Wiimote + Nunchuck pointing at the TV with IR.
Yup, same here. I purposefully watched no trailers on Zelda Breath of the Wild, just the initial art-style reveal way back in 2014. It's so much better because you get to experience more playing the game. I also try not to look stuff up except if I have to. So far I've done pretty well on that, the only thing I looked up was the "proper" way to kill Guardians in the early game because I never would have worked it out otherwise.
In Mario 3D World you actually have to play the whole game as Peach (you have to play the whole game with all the characters) if you want 100% completion in single-player mode.
Barney is not the ethical heart. Like you mention, he mistreats people who mean nothing to him, which on its own is bad enough. But he's a asshole to his friends too. He manipulated Robin into accepting his marriage proposal by tricking her into thinking he was going to marry Patrice instead. He concocted an elaborate plan over months just so he could touch Lily's pregnancy breasts. He cheats on Nora, probably the best woman for him. He designs this ridiculous pre-nup for Quinn, the woman who's his fiancée, which causes their split up. He's an ass, just like the rest of them. In fact, I think he's the worst ass of the lot, including Lily. Great character but horrible person.
With regards to the font, I've noticed that too. I think the font is great if OS display size is set to Normal, but if you set OS display size to small then the default font size is microscopic!
TIL an OS upgrade is bloatware. Truly the definition of bloatware is meaningless now.
Maybe actually read the text before claiming its an ad? Your behaviour seems to be "it has a picture; it must be an ad!!!". 
Ok, so I think I understand. You are saying that you planned to be there early to play Zelda Wii U, and had you not planned to be there early, you would have missed your flight.

I'm thinking that you should be planning to have hours to spare *regardless* if you wished to play Zelda at the airport or not. 
Powershell is now the default shell for Windows 10. You can switch the option back to Command Prompt in the Settings, but Powershell supports CMD commands, I believe, so there's not much point.
I think your comment is dangerously close to the old idea of "issue X is a bigger deal than issue Y so issue Y isn't worth focusing on". It's dangerous because you can trivialise any issue you want simply by finding another issue that's more important. 

Also, men are absolutely judged by their appearance too. Studies have shown that taller men or more​ attractive men have better jobs and higher salaries, for instance. Women also tend to prefer to go out with taller, good-looking guys (shock-horror, I know). You can acknowledge this is the case whilst also acknowledging that, yes, women are judged by their appearance more often and it's a worse issue for them in general.
I applied back in 2013, fyi, No direct contact from universities sounds rather odd though. I got a number of emails from some of them, but then I had interviews for my degree as well. 
You don't *have* to log in daily, you just get an email notification when one of your choices has updated, and, if you are lucky, an rejection email directly from the uni as well.




There is a GCSE PE, it just wasn't obligatory when I was at school. You could either do regular PE or GCSE PE and we were split up based on which we were doing. The funny part is that, initially, the GCSE PE students were doing *less* activity than the regular PE students because they were learning PE theory.
If you decide to require the Switch be docked or in range, then this would be strange to some people given that none of the processing power required to run the Wii U game is within the Switch, even if there is legitimate reasons for doing so (such as WiFi adapter and shared storage).

Time is just the first thing that came to my mind that would go out of sync if you allowed the Wii U dock to run separately from the Switch. It was the first thing because I remembered the Wii U didn't update for daylight savings manually. But Switch actually does this like a modern system should, so that's not a problem. But time isn't the only thing that would go out of sync. Other settings like changing the console nickname, language or region would also be out of sync as well. These aren't showstoppers by any stretch of the imagination, just little things that make the experience less than polished.

We are talking about expandable storage cost, and so the "significant cost" I'm talking about is the additional cost to the consumer of having to purchase 2 large-sized storage options instead of one, not the cost to Nintendo of just putting more storage in in the first place. But yeah, if Nintendo just puts more storage in in the first place then this becomes less of an issue.

The controller issues with the Virtual Console and digital vs physical Wii games was just to highlight the mess of that controller situation. I'm concerned with the complexity to the consumer here, not about anything else. I mean, look, even you didn't know about the Wii game restriction. Try popping a Wii game into the Wii U that has Classic Controller support and try actually playing it with the Gamepad/Pro Controller. You can't. My point is people get confused over which controllers can do what, just like you did just now! And that will not happen with the Switch as it stands because they just use Joycons.

Joycons cannot just sub in for the Wii Remote. The control schemes are entirely different between Joycon and Wii Remote. Even if you suggest button remapping (which adds more complexity) then IR is a problem - Wii Remotes use IR to sense when the Wii Remote is pointed at the TV, but Joycons can't do this (the IR on the right Joycon doesn't count - you can't use the Joycon upside down and still use its controls). 

Switch Pro Controllers could sub in for the other controllers, but given that you are forced to support Wii Remote for your dock (due to the reason above) then people will not be happy if you don't support Wii U Pro Controller/Wii Classic Controller also. That would look like an asshole move for sure.

There are many Wii U games that use the Wii Remote in significant ways, such as Pikmin 3, and even some where the Wii Remote is MANDATORY for either single or multiplayer use. Examples are Wii Sports Club, Nintendo Land, Wii Party U, Mario Party 10 and more. You will break compatibility with all of these Wii U games if you don't include Wii Remote support.

When I said the Switch was better off, I meant for consumers. 
I assumed that you would have the Wii U dock be able to run if the Switch console is not in proximity to the dock. After all, the original Wii U could run this way. You could use the OS and the vast majority of games without the GamePad at all. If you are going to limit the Wii U dock's to only being able to run in the proximity of the Switch, then that solves some of these issues but it's also a downgrade on what the original Wii U could do.

When I was talking about "not communicating", I meant if the Switch and Wii U dock were considerably apart from each other. So, if you are in a car trip and you update the time on the Switch then the Wii U dock back at home has the older time, which would be a problem if a second person was using the Wii U dock at home. But again, I was assuming in your solution that the Wii U dock could run separately like the original Wii U. If you are proposing that it can't, then this problem goes away.

For separate storage, I'm thinking not in terms of technical issues but in terms of cost. Using separate storage in terms of cost is less of a problem for Wii + Wii U, when all you need storage for Wii is to store a few 20-year VC games and a couple of Smash Bros screenshots. For Wii U + Switch, if you want to go the digital download route then you would need fairly large capacity​ storage for both parts. That incurs a significant cost.

The controller complexity didn't exist for Wii + GCN and PS2 + PS1 because you use only one controller for backwards compatibility. GCN - GCN controller. PS1 - exact same controller as PS2. 

That changed for Wii U + Wii. Suddenly you have Wii Remote, Wii Remote + Nunchuck, Wii Remote + Classic Controller, Wii MotionPlus, Wii U GamePad and Wii U Pro Controller. While many games worked with many of these controllers, some games would only work with one or two of these controllers. It was a mess, quite honestly. For example, if you buy a SNES game from the eShop, you can play it with the GamePad and Pro Controller, but if you buy it from the Wii Shop Channel then you have to shell out money for a Wii Remote and a Classic Controller to run it. If you have a physical Wii U game that has Classic Controller support then you cannot play the game with the GamePad or Pro Controller controls, only the Classic Controller. But if you then buy that same game off of the eShop then you *can* use GamePad or Pro Controller controls. This kind of stuff made the controller situation on Wii U very confusing.

Switch on its own doesn't have this mess, because it made a clean break from Wii and Wii U. But Switch + Wii U means having to bring back compatibility with ALL of the above peripherals and more and we are back to the same controller mess as before. In fact, you have a worse mess because now you have JoyCons and Switch Pro Controller in the mix. By having this clean break from the past, I honestly believe that the Switch is better off.

What you are proposing is different to PS3 and Wii U. 

For the PS3 and Wii U, the "old console" and the new console are in one shell. You can't remove the Wii's hardware from the Wii U without opening up the entire thing. Same with PS3. This means that the two are able to communicate with each other in certain ways.

For the Switch, the Wii U part and the Switch part are in two different pieces of casing. When you have them apart, the Wii U dock and the Switch console can't communicate in the same way. 

If you need to change the time, you either have to do it when the two pieces of hardware are together or you have to do it twice.

If you need to update the OS, it's the same thing because there are essentially two OS installations. You have to update whilst in the dock or you have to update twice.

Want to connect to WiFi but you are using MAC address filtering? Got to do that twice - you have two separate WiFi cards now.

Want to expand storage? You need to have two separate SD cards (or an SD card and a hard drive). To be fair you also had to do this for Wii inside the Wii U, but it is a bigger problem because Wii U + Switch have bigger storage requirements than Wii + Wii U. And editing storage? You guessed it - needs to be done in the dock or done separately.

These are just a few of the issues that occur - I could list a bunch more, quite honestly. And all of this complexity and confusion makes the experience worse for the consumer (and adds a significant financial cost too!). 

You may say that it's worth it if you can play Wii U games, but I strongly disagree. The premise of the Switch right now is very simple and easy to explain. You can use as a home or portable console for every game. You don't need to think "does this game support Off-TV or not?" And you only need one type of controller to play all your games - the JoyCons. You don't need to think "what controller do I need to buy/use now?" as the JoyCons work with *everything*. All this is possible because the Switch made a clean break from the Wii generations, but adding a Wii U dock would bring all of that back again.
I don't think you follow. You clearly haven't thought through the logistics of what you are proposing. 

If you are going to have the Switch be fully portable whilst also being able to play Wii U games with the Switch as a GamePad controller, then you have to have a duplication of all internal parts. CPU, GPU, storage, RAM, network cards, fans, the lot. One set inside the dock, one set inside the Switch. You also have to have a duplication of software - you need two separate installations of the operating system to handle both scenarios.

You end up with two separate consoles that pretend that they are one console when they are not. And that fact can be seen by all. In Switch portable mode you can *only* play Switch games, but in Wii U dock mode you can *only* play Wii U games. You can't do the opposite. It becomes very obvious, very quickly than this two consoles masquerading poorly as one.
This is not a dock then, it's a console. It's a Wii U without the GamePad. It's essentially entirely separate to the Switch since you just want the Switch to act as a dumb controller. 
Wiimote plus requires sensor bar calibration for some games, like Zelda Skyward Sword. However in the games you mentioned, that's not relevant at all. 
I think that's the main reason but I doubt that's the *only* reason. If that literally was the only motivation, why not just release Breath of the Wild for Switch only? You have the same effect of moving Switches without the effort needed to get the game running on Wii U.
> Also annoyed that the Switch doesn't have an option for WiiU backwards compatibility: just make the dock a disc loader that outputs screen one on HDMI and then the Switch tablet be the controller. Easy. But alas...

Your configuration makes no sense whatsoever - if the Switch is the controller then the disc loader has no access to the Switch console, which means no access to SoC, memory and so forth, which means no game running.
It was pack-in with the launch versions of the Wii U Premium/Deluxe edition.
More like the sexless taxi driver. 
For Wii U, it's simply personal preference. I don't think any layout would have been better or worse, quite honestly. But for Switch, I miss the two sticks up top . Currently, the right stick pushes up against your hand when you try to push the ABXY buttons. If the right-stick was above ABXY (like on the left side) this problem would go away (although then you couldn't use the JoyCons as two controllers).
I understand that, for me it was the case for most of the games. But I think Wind Waker HD is the exception. Wind Waker HD, if you are playing with the Pro Controller, requires you to pause sailing to check the map, and then unpause sailing to orient your boat. With the GamePad, you don't pause sailing. You look down, orient your boat and look up. Clearly to me the first is more jarring than the second.
With the Nexus 5X, I'm not sure if that one is their fault given that the Nexus 6P bootlooped as well. But the others definitely are.
Alternatively, if you enable the Material Design settings page from chrome://flags, that will also tell you what theme you have installed.
Since the app store is technically the same for Windows 10 desktop and mobile, they won't be closing the store any time soon. If they do drop mobile apps, it will only happen once they announce an official end to Windows 10 Mobile. I can't see them dropping all the mobile apps whilst development for Windows 10 Mobile is still going on (even if that development is token development at best).
You really need 2 GB RAM for Android these days. 1 GB is useable but it's a miserable experience.
If you type, you see the text appear at the top. It's obvious that they need to rework that bit of the UI though, it looks crappy for sure.
People have mentioned this many times - seems to be a Chrome bug. One of the people installing my themes said that reinstalling the theme did the trick.
That's a shame. I had a *really* good interview with Bank of America. Was expecting it to be hostile, you know, cos it's banking. But no, the manager is genuinely one of the nicest people I have the pleasure of knowing and the interview was a "soft" interview - more like a discussion than anything else. 

I guess it help that I am working for the London branch in a developer team though. Pretty much everyone I know in our department are good people and there's a very good team rapport.
And next year we'll see the NuAns Neo Revolution...?
They aren't upgrading everybody's device at once. My device hasn't got the notification yet. 
The conclusions that I put right at the top of my first comment. Claiming that Windows phone has a better community and that the two platforms are tied on apps. I can't take you seriously having made those conclusions.
You missed out a huge ton of what I said, but I'll reply anyway.

Being called out on being biased is a criticism of your piece. To me, you seem to be using the fact that you admit to being biased as a way to shield yourself from this criticism. The criticism stands whether you admit it or not.

Your "week-long" thoughts are useless then. My criticism still stands - you haven't looked at the two OSs fairly. And if you aren't doing a review, don't make conclusions between the two OSs. 

The ability to root and custom-ROM​ your phone has created in itself a community of people that want to customise their phones to a significant degree. This community barely exists for Windows phone because of this face. Rooting and custom-ROMs have everything to do with community.
Acknowledging that you are biased doesn't give you a pass from criticism of your review. Every reviewer is biased to some extent, no one is truly unbiased when reviewing a product because we all have our likes and dislikes. However, most reviewers that care about giving an accurate review try to put their biases to one side to review the product in an objective light. You did not. You nitpicked about Android's minor issues and ignored to mentioned things Android does better whilst completely glossing over Windows phone's massive fucking issues. Your review is useless to all but the diehardest, most deluded fanboys.

Both platforms can be improved in apps, in the same way that both you and Usain Bolt could both probably improve your 100m sprint times. iOS and Android are so ahead of the pack, it's not even funny. This is the conclusion of pretty much everyone who reviews these OSs, even those who love the Windows phone platform. You have to be kinda deluded at this point to argue otherwise. For every good app on Windows phone, 10 probably exist on iOS/Android. Windows phone's app catalogue is simply lackluster by comparison. Windows phone has many missing official apps. In the last year, many many official apps have been pulled from the Windows Store. When an app does come to Windows phone, it's usually late to the platform, or it's often buggy and/or slow, or it gets updated later on Windows phone compared to other platforms, or it never gets updated at all. Let's not forget even when there is a good UWP app that suffers from none of these issues, the vast majority of the Windows phone community cannot use it as they are stuck on Windows Phone 8.1 or lower.

It's hilarious that you think the Windows phone community is better. This sub is far more negative and toxic than the Apple or Android subreddits. It's telling that those subreddits never had to have "I'm leaving the platform" threads sticked to the top of the subreddit. You ignore those more mainstream communities whilst focusing on XDA only. And when you do focus on XDA, you are totally unfair in your analysis. Yes, XDA is confusing as all hell. But at least you CAN root and custom-ROM your phone. At least there IS a community that will let you change up your whole phone. You neglect to mention that this kind of community is virtually absent on Windows phone. You neglect to mention that 99% of things you can do on Android from XDA are things you CANNOT do on Windows phone. This is because of Microsoft releasing closed source, locked bootloader phones, which work to actively stifle the community. And you neglect to mention projects like LineageOS that make it much easier to custom-ROM your phone. Those are the problems with your analysis of both communities.

tl;dr: Your review sucks and is useless.
> Community - winner - Windows phone

> Apps - tie between Android and Windows phone

Whilst a lot of your review is debatable, I have to fucking lol at these conclusions. No fair reviewer would ever come to them. You are biased crazily in favour of Windows phone to the point that your conclusions cannot be taken seriously.
Are you in normal mode or Incognito mode? If you are in normal mode, it's likely that you have a theme that just got updated.
For me, it was the case. The difference that I found between school and university was not the difficulty of the work, but the quantity of it. There were very few concepts in uni which I found difficult to grasp, the challenger was always trying to cram all those different concepts into my head come exam time. 
Lol, "security" extensions. Many of these are "I don't like advertising" extensions, where people use security as a convenient excuse even though security was never the real reason in the first place
I have said twice now that I have no problem with people having preferences. You seem to be trying to persuade me of something that I already agree with you on. It's the people who are rude to others that don't fit their preferences that I don't like, and the people who think their preferences don't make them shallow that I disagree with.
People use the phrase "settle for less" when they perceive that they are getting something worse. That's not my projection - the phrase is commonly used for exactly that definition, and not just for relationship preferences.

I think that the height thing is not solely natural - it's also influenced by media much like other desirable physical characteristics.

I have no problem with people having preferences, it's just recognising that these are preferences are subjective and that having preferences on physical attraction also makes you shallow to a certain degree too.
Yup, whilst I think the height thing tends to be more of a women thing, guys also have their own shallow preferences. 
I'm just using the word that the person I replied to use.

Whilst I don't mind people having preferences, I do resent the language used sometimes, such as yours. These are subjective preferences we are talking about. "Why settle for less" implies that being a shorter person is inherently a bad thing to be.
Depends on what you are doing. Not everyone uses monitors for gaming. If you don't game, 144Hz is pretty much useless.
I think part of it is body standards driven by the media (same for both men and women). And I think part of it is "what will people say if they see me next to a short guy" as well.
I don't think that having the preference in itself is a bad thing. Sure it's shallow, but everyone is shallow to some degree or other. I think the way it's communicated online matters. There's a difference between saying "I prefer x height/y weight" and saying "Don't contact me if you are under x height/over y weight". The latter seems unnecessarily rude.
60Hz - *literally unusable*
The threshold height can vary. I've seen it as high as 6' and beyond.
GG4 devices scratch at a level 6 Mohs scale of hardness, same as GG3. Keys and coins won't scratch the display, only sand and small particles. Look at any scratch test of a GG4 online and you'll see this is the case. 
There is definitely a small proportion of girls that do care. I judge that simply off seeing a number of girl's dating profiles saying only to contact them if you are a threshold height over 5'8". I don't think that it's particularly widespread, perhaps around 5% of women if I had to base it just off what I've seen, but it's definitely​ there. 
In that case, quite a few women have ridiculous dating standards. I've seen a small but significant proportion of women on dating sites saying only to contact them if you have a threshold height of 5'8” or more. 
It's been miserable for a very long time. Brexit did not help matters at all, but the sub was very depressing way before that. The sub is aggressively left-wing so very often it's like the British version of /r/politics. Unless you personally like the idea of fellating Jeremy Corbyn, you will not enjoy it 
You're right, putting the flag back would make no sense. That flag was only ever meant to be temporary. 
I put a story out as an April Fool's Joke about​ that - that the flag was coming back. No one seemed to get that it was fake though...
It's pretty cool they got Patrick Warburton to do that video.
When it's one manual, sure, it's pretty easy. But I bought an IKEA wardrobe that was basically 14 separate IKEA products which can be put together to make a wardrobe. This meant 14 separate IKEA manuals, many of which were very vague because the product in question was designed to be used with many wardrobes and not just the one I was assembling. 
I don't mind about the Conversation Street intro because I actually find it humourous and it's only a few seconds. Celebrity Brain Crash on the other hand is a couple of minutes long and utter crap. It seriously needs to be buried and never seen again.